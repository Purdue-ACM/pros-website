<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on PROS</title>
    <link>http://pros.cs.purdue.edu/tutorials/index.xml</link>
    <description>Recent content in Tutorials on PROS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MPL 2.0 license</copyright>
    <atom:link href="http://pros.cs.purdue.edu/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Analog Sensors</title>
      <link>http://pros.cs.purdue.edu/tutorials/analog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/analog/</guid>
      <description>

&lt;p&gt;While computers, microcontrollers, and other devices that interface with VEX robots are digital systems, most of the real world operates as analog components, where a range of possible values exist instead of simply an arrangement of 1s and 0s. To communicate with these analog real-world systems, analog sensors like potentiometers and line trackers are used. These sensors return a number within a preset range of values in accordance with their input, as opposed to a digit sensor which simply returns an on or off state.&lt;/p&gt;

&lt;p&gt;To take these analog inputs and convert them to information that the Cortex can actually use, ADCs (Analog to Digital Converters) are used on each of the Analog In ports to convert the analog input signals (varying voltage signals) to 12 bit integers. As a result, the range of all analog sensors when used with the Cortex is 0 to 4095 (the range of a 12 bit unsigned integer).&lt;/p&gt;

&lt;h2 id=&#34;initialization&#34;&gt;Initialization&lt;/h2&gt;

&lt;p&gt;Unlike many of the other VEX sensors, no initialization process is needed in the &lt;code&gt;initializeIO()&lt;/code&gt; or &lt;code&gt;initialize()&lt;/code&gt; functions. However, it is often worthwhile to calibrate analog sensors before using them, which would take place in the &lt;code&gt;initialize()&lt;/code&gt; function. The &lt;a href=&#34;http://pros.cs.purdue.edu/api/#analogCalibrate&#34;&gt;&lt;code&gt;analogCalibrate()&lt;/code&gt;&lt;/a&gt; function collects approximately 500 data samples over a period of half a second and returns the average value received over the sampling period. This average value can be used to account for variations like gyroscope orientation or ambient light for line trackers.&lt;/p&gt;

&lt;h2 id=&#34;potentiometer&#34;&gt;Potentiometer&lt;/h2&gt;

&lt;p&gt;Potentiometers measure angular position and can be used to determine the direction of rotation of its input. Potentiometers are best used in applications such as lifts where the sensor is not at risk of being rotated beyond its 250-degree physical constraint. Potentiometers typically do not need to be calibrated, although it may be desired as it helps account for possible shifting in the potentiometer mounting and to find the actual range of the potentiometer due to its mechanical stops as that range may be closer to 5-4090 instead of 0-4095. If the potentiometer is not calibrated, the &lt;a href=&#34;http://pros.cs.purdue.edu/api/#analogRead&#34;&gt;&lt;code&gt;analogRead()&lt;/code&gt;&lt;/a&gt; function may be used to obtain the raw input value of the potentiometer. If the sensor was calibrated, the &lt;a href=&#34;http://pros.cs.purdue.edu/api/#analogCalibrate&#34;&gt;&lt;code&gt;analogReadCalibrated()&lt;/code&gt;&lt;/a&gt; function should be used, as it will account for the sensor&amp;rsquo;s calibration and return more accurate results. The input to both of these functions is the channel number of the sensor, and an integer is returned.&lt;/p&gt;

&lt;p&gt;Thus an example of use on a lift would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define POTENTIOMETER_PORT 1
#define LIFT_MOTOR 1

//while the potentiometer is not at its maximum position
while(analogRead(POTENTIOMETER_PORT) &amp;lt; 4095)
{
  motorSet(1,127); //activate the lift
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;line-tracker&#34;&gt;Line Tracker&lt;/h2&gt;

&lt;p&gt;VEX Line Trackers operate by measuring the amount of light reflected to the sensor and determining the existence of lines from the difference in light reflected by the white tape and the dark tiles. The Line Trackers return a value between 0 and 405, with 0 being the lightest reading and 4095 the darkest. It is recommended that Line Trackers be calibrated to account for changes in ambient light.&lt;/p&gt;

&lt;p&gt;An example of Line Tracker use:&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define LINE_TRACKER_PORT 1
#define DRIVE_MOTOR_LEFT 1
#define DRIVE_MOTOR_RIGHT 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void initialize() {
  analogCalibrate(LINE_TRACKER_PORT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

//2000 arbitrarily set as cutoff between light and dark
while(analogReadCalibrated(LINE_TRACKER_PORT) &amp;lt; 2000)
{
  // drive forward until a line is hit
  motorSet(DRIVE_MOTOR_LEFT,127);
  motorSet(DRIVE_MOTOR_RIGHT,127);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gyroscope&#34;&gt;Gyroscope&lt;/h2&gt;

&lt;p&gt;One of the most powerful sensors available for the VEX Cortex is the VEX Yaw Rate Gyro. Through proper utilization of this sensors you can consistently make your robot perform precise turns.&lt;/p&gt;

&lt;h4 id=&#34;warning&#34;&gt;Warning&lt;/h4&gt;

&lt;p&gt;The VEX Yaw Rate Gyro is an analog sensor which means that it is very susceptible to analog noise during its operation. When utilizing this sensor, pay special attention to the connection wires between cortex and the gyro and keep them far away from motors.&lt;/p&gt;

&lt;p&gt;PROS provides a gyro library to simplify using it. A sample usage would be as follows:&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Analog port number gyro is plugged into
#define GYRO_PORT 1

// Multiple gyros can be declared
Gyro gyro;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize(){
    // ... Other sensor initialization and port configuration
    // If gyro reads inaccurately, change &amp;quot;0&amp;quot; to desired sensitivity
    // See documentation on gyroInit() for up-to-date sensitivity details
    gyro = gyroInit(GYRO_PORT, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c or auto.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(){
    // ... Do work
    // Get gyro reading in degrees
    int heading = gyroGet(gyro);

    // ... Do other work
    // Reset the gyro to zero
    gyroReset(gyro);

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;accelerometer&#34;&gt;Accelerometer&lt;/h2&gt;

&lt;p&gt;The VEX Accelerometer measures acceleration on the x, y, and z axes simultaneously. Accelerometers can be used to infer velocity and displacement, but due to the error induced by such integration it is recommended that simply the acceleration data be used. By design of the VEX Accelerometer each axis is treated as its own analog sensors. Due to this the VEX Accelerometer requires three analog input ports on the Cortex.&lt;/p&gt;

&lt;p&gt;Example accelerometer use:&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define ACCELEROMETER_X 1
#define ACCELEROMETER_Y 2
#define ACCELEROMETER_Z 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void initialize() {
  analogCalibrate(ACCELEROMETER_X); //calibrates the x axis input
  analogCalibrate(ACCELEROMETER_Y); //calibrates the y axis input
  analogCalibrate(ACCELEROMETER_Z); //calibrates the z axis input
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

//Read the acceleration data for each axis
int x_acc = analogReadCalibratedHR(ACCELEROMETER_X);
int y_acc = analogReadCalibratedHR(ACCELEROMETER_Y);
int z_acc = analogReadCalibratedHR(ACCELEROMETER_Z);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Buttons and digitalRead</title>
      <link>http://pros.cs.purdue.edu/tutorials/digitalRead/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/digitalRead/</guid>
      <description>&lt;p&gt;Buttons such as the limit switch that VEX provides are digital sensors. These sensors are generally used as triggers for various events such as a robot hitting an object or the wall. One special difference from other sensors is that you need to configure the pin they are connected to as an input. PROS provides a simple interface to perform such tasks that is as follows:&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// digital port number limit switch is plugged into
#define LIMIT_SWITCH 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initializeIO(){
    // configure the pin that the limit swith is plugged into as an input
    pinMode(LIMIT_SWITCH, INPUT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c or auto.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(){
    // ... Do work
    // digitalRead() will return LOW if PRESSED and HIGH if RELEASED
    if (digitalRead(LIMIT_SWITCH) == LOW){
        // ...
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Coding FAQ</title>
      <link>http://pros.cs.purdue.edu/tutorials/coding-faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/coding-faq/</guid>
      <description>

&lt;h2 id=&#34;compile-time&#34;&gt;Compile-Time Issues&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;undefined reference to ...&lt;/code&gt; or &lt;code&gt;implicit declaration of function ...&lt;/code&gt;: &lt;br/&gt;
A function name is spelled incorrectly, or the function was incorrectly declared in a header file. Custom headers must be included in &lt;code&gt;main.h&lt;/code&gt; or in the file in which they are used.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;format ... expects argument of type ..., but argument has type ...&lt;/code&gt;: &lt;br/&gt;
The value provided to a function like &lt;a href=&#34;http://pros.cs.purdue.edu/api/#printf&#34;&gt;&lt;code&gt;printf()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://pros.cs.purdue.edu/api/#lcdPrint&#34;&gt;&lt;code&gt;lcdPrint()&lt;/code&gt;&lt;/a&gt; does not match the expected type inferred from the format string. Some instances of this warning can be safely ignored, but crashes can occur if types &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;long long&lt;/code&gt; are mixed with other types.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;assignment makes pointer from integer without a cast&lt;/code&gt;: &lt;br/&gt;
Typically caused when a C pointer has the wrong number of asterisks to &lt;a href=&#34;http://stackoverflow.com/a/4955297/3681958&#34;&gt;dereference&lt;/a&gt; it, or when assigning a constant to &lt;code&gt;pointer&lt;/code&gt; (instead of &lt;code&gt;*pointer&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;run-time-issues&#34;&gt;Run-Time Issues&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Some tasks are running, others are not:&lt;/strong&gt; &lt;br/&gt;
A task is not waiting using &lt;a href=&#34;http://pros.cs.purdue.edu/api/#delay&#34;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://pros.cs.purdue.edu/api/#taskDelayUntil&#34;&gt;&lt;code&gt;taskDelayUntil()&lt;/code&gt;&lt;/a&gt;. Due to the fact that PROS utilizes a priority based non-preemptive scheduler, tasks of higher or equal priority to the blocking task will still run while lower priority tasks will not. This scenario is also known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Starvation_(computer_science)&#34;&gt;starvation&lt;/a&gt;. See &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/tasks/&#34;&gt;Tasks/Multithreading&lt;/a&gt; for more information.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;VEX LCD updates very slowly or is &amp;ldquo;frozen&amp;rdquo;:&lt;/strong&gt; &lt;br/&gt;
A task is not waiting using &lt;a href=&#34;http://pros.cs.purdue.edu/api/#delay&#34;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://pros.cs.purdue.edu/api/#taskDelayUntil&#34;&gt;&lt;code&gt;taskDelayUntil()&lt;/code&gt;&lt;/a&gt;. From the kernel&amp;rsquo;s perspective, updating the LCD is usually less important than how well the robot is running, so PROS prioritizes user tasks over the LCD. &lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;The LCD is only updated if all other tasks are waiting.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Neither autonomous nor driver control code starts:&lt;/strong&gt; &lt;br/&gt;
The &lt;code&gt;initialize()&lt;/code&gt; function may still be running. Some tasks such as &lt;a href=&#34;http://pros.cs.purdue.edu/api/#gyroInit&#34;&gt;&lt;code&gt;gyroInit()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://pros.cs.purdue.edu/api/#analogCalibrate&#34;&gt;&lt;code&gt;analogCalibrate()&lt;/code&gt;&lt;/a&gt; take time.&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;initialize()&lt;/code&gt; function implements some type of loop or autonomous selection routine, verify that it actually has a means of ending.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Code restarts unexpectedly:&lt;/strong&gt; &lt;br/&gt;
A run-time error has caused the program to crash. &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/debugging/&#34;&gt;Debugging&lt;/a&gt; may reveal the cause of the error. Examine any newly added code for possible logical errors. Some common error messages include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Segmentation Fault:&lt;/strong&gt; &lt;br/&gt;
Indicates that an invalid C pointer has been used. Check for confusion between pointers and regular variables and that an invalid pointer has not been passed to a PROS API function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Stack Overflow:&lt;/strong&gt; &lt;br/&gt;
Often indicates infinite recursion, or that the stack size for a custom task is too small. Calling many layers of functions and declaring large local variables can require large amounts of space on the stack. If this error occurs in a default task like &lt;code&gt;autonomous()&lt;/code&gt;, consider changing code to reduce the stack requirements, or creating a new task with a larger stack size using &lt;a href=&#34;http://pros.cs.purdue.edu/api/#taskCreate&#34;&gt;&lt;code&gt;taskCreate()&lt;/code&gt;&lt;/a&gt; to handle large jobs. Large arrays declared inside functions can usually be declared globally to alleviate pressure on stack space.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;System Task Failure:&lt;/strong&gt; &lt;br/&gt;
Too many tasks were running for the system to start a new one. Disable or merge unnecessary tasks to eliminate this error.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Cortex blinking red light after upload:&lt;/strong&gt; &lt;br/&gt;
Turn the Cortex microcontroller off and on again. This usually resolves the problem, and it is generally good practice to re-initialize the robot to simulate conditions at most competitions. If the error persists, see the &amp;ldquo;&lt;strong&gt;Code restarts unexpectedly&lt;/strong&gt;&amp;rdquo; section above.&lt;br/&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://pros.cs.purdue.edu/api/#printf&#34;&gt;&lt;code&gt;printf()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t work&lt;/strong&gt;: &lt;br/&gt;
&lt;a href=&#34;http://pros.cs.purdue.edu/api/#printf&#34;&gt;&lt;code&gt;printf()&lt;/code&gt;&lt;/a&gt; prints information over a serial connection (see &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/debugging/&#34;&gt;Debugging&lt;/a&gt;), not to the VEX LCD. To print to the LCD, use &lt;a href=&#34;http://pros.cs.purdue.edu/api/#lcdPrint&#34;&gt;&lt;code&gt;lcdPrint()&lt;/code&gt;&lt;/a&gt; instead.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Debugging in PROS</title>
      <link>http://pros.cs.purdue.edu/tutorials/debugging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/debugging/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;http://pros.cs.purdue.edu/api/&#34;&gt;PROS API&lt;/a&gt; provides various functions, like &lt;a href=&#34;http://pros.cs.purdue.edu/api/#print&#34;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;http://pros.cs.purdue.edu/api/#printf&#34;&gt;&lt;code&gt;printf()&lt;/code&gt;&lt;/a&gt;, that allow your robot to output information to a connected serial console during operation.&lt;/p&gt;

&lt;p&gt;###To view a robot&amp;rsquo;s output, there are two officially supported methods:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Through the PROS CLI: &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;pros terminal&lt;/code&gt; on the command line will open an output stream from a robot connected over direct USB connection, VEXnet, or &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/jinx/&#34;&gt;JINX&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;From within Atom: &lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Click the button labeled &amp;ldquo;Open cortex serial output&amp;rdquo;&lt;br /&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/open-cortex.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;A terminal panel will open at the bottom of the screen containing the output of a connected robot.&lt;br/&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/terminal-platformio.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Alternate method: &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Use the serial communication monitor of your choice (such as &lt;a href=&#34;http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html&#34;&gt;PuTTY&lt;/a&gt;, &lt;a href=&#34;http://freeware.the-meiers.org/&#34;&gt;CoolTerm&lt;/a&gt; or &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=EgorGrushko.SerialMonitor&#34;&gt;this plugin for Visual Studio&lt;/a&gt; if using Visual Studio) with the following settings: &lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Serial Port:&lt;/strong&gt; May vary; unplugging and replugging the VEXnet device from the computer should allow you to determine the correct port.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Baud Rate:&lt;/strong&gt; &lt;em&gt;115200&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Encoding:&lt;/strong&gt; &lt;em&gt;28591 - ISO-8859-1 - Western European (ISO)&lt;/em&gt; or equivalent&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Encoders</title>
      <link>http://pros.cs.purdue.edu/tutorials/encoders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/encoders/</guid>
      <description>

&lt;h2 id=&#34;quad-encoder&#34;&gt;Quad Encoder&lt;/h2&gt;

&lt;p&gt;Quadrature encoders can measure the rotation of the attached axle on your robot. Most common uses of this sensor type are to track distance traveled by attaching them to your robots drivetrain and monitoring how much the axle spins.&lt;/p&gt;

&lt;p&gt;With these sensors 1 measured tick is 1 degree of revolution.&lt;/p&gt;

&lt;p&gt;PROS provides a simple quadrature library to utilize these sensors. A sample usage would be as follows:&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Digital port number for top and bottom port of quad encoder
#define QUAD_TOP_PORT 1
#define QUAD_BOTTOM_PORT 2

// Multiple encoders can be declared
Encoder encoder;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize() {
    // ...
    encoder = encoderInit(QUAD_TOP_PORT, QUAD_BOTTOM_PORT, is_reversed);
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c or auto.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(){
    // ... Do work
    // Get encoder reading in degrees
    int counts = encoderGet(encoder);

    // ... Do other work
    // Reset encoder to zero
    encoderReset(encoder);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wiring-notes&#34;&gt;Wiring Notes&lt;/h3&gt;

&lt;p&gt;One important thing to note with the use of encoders is that they should &lt;strong&gt;not&lt;/strong&gt; be plugged into digital &lt;strong&gt;port 10&lt;/strong&gt; on the Cortex. This is not unique to PROS, it is simply a result of the way that &lt;a href=&#34;http://users.ece.utexas.edu/~valvano/Volume1/E-Book/C12_Interrupts.htm&#34;&gt;digital interrupts&lt;/a&gt; are configured for the Cortex. Other types of sensors may be used on port 10 with no effect on their performance, but encoders cannot.&lt;/p&gt;

&lt;h2 id=&#34;integrated-motor-encoders-imes&#34;&gt;Integrated Motor Encoders (IMEs)&lt;/h2&gt;

&lt;p&gt;See the &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/i2c.md/#vex-integrated-motor-encoder-ime&#34;&gt;I2C Communication&lt;/a&gt; page.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>I2C Communication</title>
      <link>http://pros.cs.purdue.edu/tutorials/i2c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/i2c/</guid>
      <description>

&lt;p&gt;Inter-Integrated Circuit or I2C communications is but one of the common embedded communications protocols found commonly in robotics at large.  It sports a master-slave configuration as well as a unified bus allowing devices to be daisy-chained together in series if so desired.  A standard I2C bus consists of two signals seen by all devices - Serial Data (SDA) and Serial Clock (SCL).  These two signals are found alongisde +5V and GND power rails in the VEX Cortex I2C port to supply power to any attached I2C slave devices.&lt;/p&gt;

&lt;p&gt;The primary I2C device encountered in VEX is the &lt;a href=&#34;http://www.vexrobotics.com/encoder-modules.html&#34;&gt;Integrated Motor Encoder (IME)&lt;/a&gt;; VEX U teams or hobbyists may feel so inclined to connect third-party I2C sensors to their robots such as gyroscopes or lidars.  This tutorial aims to cover writing to and reading from I2C slave devices, a rundown of the IME-specific functions provided, and transisition into topics such as device initialization and polling tasks for managing multiple I2C slaves at once.&lt;/p&gt;

&lt;p&gt;In a future update this tutorial will strive to provide a brief summary of the I2C protocol itself, but in lieu of our own take on the subject please review the excellent rundown provided by SparkFun located &lt;a href=&#34;https://learn.sparkfun.com/tutorials/i2c&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;writing-to-an-i2c-slave&#34;&gt;Writing to an I2C Slave&lt;/h2&gt;

&lt;p&gt;PROS low-level and initialization functions establish the VEX Cortex as an I2C master device, thus the primary I2C action it will perform is writing to I2C slave devices attached to it.  During I2C slave initialization and operation it is common to modify single byte registers in non-sequential locations of the slave&amp;rsquo;s memory.  In these cases PROS provides the &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cWriteRegister&#34;&gt;i2cWriteRegister()&lt;/a&gt;.  A sister function &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cWrite&#34;&gt;i2cWrite()&lt;/a&gt; is better used when writing to sequential bytes of an I2C slave such as providing full 32-bit integer parameters.  When using &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cWrite&#34;&gt;i2cWrite()&lt;/a&gt; the first byte of the data argument should be the first register of the slave being written to.  Shown below is a short example of initializing and configuring a fictional I2C slave sensor.&lt;/p&gt;

&lt;p&gt;main.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 7-bit address of the slave I2C device, right aligned
#define I2C_SLAVE_ADDR         0x4A
// Ficitonal &amp;quot;enable&amp;quot; register for the device
#define I2C_SLAVE_REG_ENABLE   0x38
// Fictional 32-bit &amp;quot;parameters&amp;quot; buffer for the device, 0x6D-0x6F
#define I2C_SLAVE_BUF_PARAMS   0x6D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void initialize() {
    // Note the address of the first register of the buffer is first in the message
    uint8_t params[5] = {I2C_SLAVE_BUF_PARAMS, 0x50, 0x52, 0x79, 0x53};

    // Send the slave some parameters
    if (i2cWrite(I2C_SLAVE_ADDR, params, 5)) {
        printf(&amp;quot;Parameters sent successfully!\n&amp;quot;);
    }
    else {
        printf(&amp;quot;ERROR: Failed to send parameters to I2C slave!\n&amp;quot;);
    }

    // And then enable the device
    if (i2cWriteRegister(I2C_SLAVE_ADDR, I2C_I2C_SLAVE_REG_ENABLE, 0x01)) {
        printf(&amp;quot;I2C slave enabled!\n&amp;quot;);
    }
    else {
        printf(&amp;quot;ERROR: Failed to enable the I2C slave!\n&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;readingI2CSlave&#34;&gt;Reading from an I2C Slave&lt;/h2&gt;

&lt;p&gt;As the vast majority of I2C slave devices serve as sensors, PROS provides both &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cRead&#34;&gt;i2cRead()&lt;/a&gt; and &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cReadRegister&#34;&gt;i2cReadRegister()&lt;/a&gt; to receive data from them.  Since I2C slave devices do not emit data onto the bus without the request of the master device, &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cRead&#34;&gt;i2cRead()&lt;/a&gt; is limited in its usefulness.  To that extent, below is an example showing how to read from data from a fictional sensor using the more typical &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cReadRegister&#34;&gt;i2cReadRegister()&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;main.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 7-bit address of the slave I2C device, right aligned
#define I2C_SLAVE_ADDR       0x4A
// Fictional 32-bit data buffer for the device, 0x30-0x34
#define I2C_SLAVE_BUF_DATA   0x30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;auto.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void autonomous() {
    uint8_t dataIn[4];
    int32_t reading = -1;

    while (1) {
        if (i2cReadRegister(I2C_SLAVE_ADDR, I2C_SLAVE_BUF_DATA, data_in, 4)) {
            // Combine the 8-bit incoming values by extending them and bitwise-oring them together
            //
            // NOTE: Extension to 32-bits is done using uint32_t even though reading is int32_t
            //       This is done to prevent &amp;quot;sign extension,&amp;quot; a common problem in these scenarios
            //
            // NOTE: This implementation assumes incoming data is big-endian with the order (0, 1, 2, 3)
            //       If your I2C slave emits data as little-endian, the order needs to be reversed
            reading = (((uint32_t)dataIn[0]) &amp;lt;&amp;lt; 24) |
                      (((uint32_t)dataIn[1]) &amp;lt;&amp;lt; 16) |
                      (((uint32_t)dataIn[2]) &amp;lt;&amp;lt;  8) |
                      (((uint32_t)dataIn[3]));

            printf(&amp;quot;Read in a value of %d from slave.\n&amp;quot;, reading);
        }
        else {
            reading = -1;
            printf(&amp;quot;ERROR: Failed to read sensor data from slave!\n&amp;quot;);
        }

        // Use the sensor value in some way here

        delay(20);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vex-integrated-motor-encoder-ime&#34;&gt;VEX Integrated Motor Encoder (IME)&lt;/h2&gt;

&lt;p&gt;IMEs function a lot like the quadrature encoders except they are directly attached to the motor rather than mounted to a mechanism on your robot. In addition these sensors utilize the I2C bus on the cortex and can be daisy chained together on your robot.&lt;/p&gt;

&lt;h3 id=&#34;advance-user-warning&#34;&gt;Advance User Warning&lt;/h3&gt;

&lt;p&gt;When utilizing IMEs and 3rd party sensors on your I2C bus it is recommended that you write your own task to handle all the I2C communication to prevent resource thrashing. See the &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/i2c/#pollingTask&#34;&gt;I2C Polling Task&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;PROS provides a simple library for interacting with your IMEs. A sample usage would be as follows:&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define IME_LEFT_MOTOR 0
#define IME_RIGHT_MOTOR 1
#define NUMBER_OF_IME 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize(){
    // ...
    // Check count to ensure all IMEs are plugged in!
    int IMECount = imeInitializeAll();
    if(IMECount != NUMBER_OF_IME){
        // something has gone wrong
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrolc or auto.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction(){
    // ... do work
    // Get IME tick count in the &amp;quot;counts&amp;quot; variable
    // (conversion to rotations varies depending on the motor type in use)
    int counts;
    imeGet(0, &amp;amp;counts);

    // Or if #define was used:
    imeGet(IME_LEFT_MOTOR, &amp;amp;counts);

    // ... Do other work
    // Reset IME to zero
    imeReset(IME_RIGHT_MOTOR);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;thirdPartyI2CDevices&#34;&gt;Third-Party I2C Devices&lt;/h2&gt;

&lt;!--- TODO mention consulting datasheets --&gt;

&lt;p&gt;Writing to and reading from third-party I2C devices with the Cortex using PROS is a relatively painless process with the techniques described earlier in this tutorial.  PROS essentially only requires the 7-bit I2C address of the target slave and a register you wish to interact with if any.  These can all be found in the third-party device&amp;rsquo;s datasheet.&lt;/p&gt;

&lt;p&gt;The great deal of effort in connecting a third-party I2C slave comes in scouring its datasheet and synthesizing its instructions into a device driver.  A critical aspect of this driver is its initialization routine.  Since I2C slave sensors often have their own microprocessors present, they may require several registers to be configured and an enable register to be set before they will even begin collecting data.  It is recommended that a &lt;code&gt;Xinit()&lt;/code&gt; function be created for sensor X (e.g. lidarInit, gyroInit, etc) so that it may be called from different locations in the robot code rather than hard-coding the setup protocol into &lt;code&gt;init.c&lt;/code&gt;.  This way if the device were to ever lose power or disconnect a reconnection attempt is feasible.  This &lt;code&gt;Xinit()&lt;/code&gt; function will contain several calls to &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cWriteRegister&#34;&gt;i2cWriteRegister()&lt;/a&gt; and &lt;a href=&#34;http://pros.cs.purdue.edu/api/#i2cReadRegister&#34;&gt;i2cReadRegister()&lt;/a&gt; that follow the datasheet&amp;rsquo;s instructions to bring the sensor up and running.&lt;/p&gt;

&lt;p&gt;In addition to an initialization routine for the third-party sensor, it is good practice to group multiple sequential write/read operations into routines as well.  This can drastically improve code readability and portability to future robots.  A simple device driver for a fictional lidar is given below.&lt;/p&gt;

&lt;p&gt;lidar.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// The 7-bit I2C address of the lidar sensor
// Found in its manufacturer datasheet
#define LIDAR_ADDR              0x67
#define LIDAR_REG_CFG_ADDR      0x10
#define LIDAR_BUF_VALUE_ADDR    0x4C

// Allowed values for the PVAL bits of the CFG register on the lidar
enum {
    SQ = 0x00,
    LQ = 0x01,
    MQ = 0x02,
    HQ = 0x03
} LIDAR_REG_CFG_PVAL;

// Allowed values for the EN bit of the CFG register on the lidar
enum {
    DISABLE = 0x00,
    ENABLE = 0x01
} LIDAR_REG_CFG_EN;

// Allowed values for the ITR bit of the CFG register on the lidar
enum {
    DISABLE = 0x00,
    ENABLE = 0x01
} LIDAR_REG_CFG_ITR;

// Global union with convenient structure for accessing bitfields
// rather than defining a gazillion bitmasks
union {
    struct {
        uint8_t PVAL0  : 2;
        uint8_t unused : 1;
        uint8_t PVAL1  : 2;
        uint8_t unused : 1;
        uint8_t EN     : 1;
        uint8_t ITR    : 1;
    } field;
    uint8_t all;
} LIDAR_REG_CFG = {.all = 0};

// Global union for accessing the individual bytes of a 32-bit int sensor reading
union {
    uint8_t byte[4];
    int32_t value;
} LIDAR_BUF_VALUE {.value = 0};

// Function declarations
bool lidarInit();
bool lidarSetLowRes();
bool lidarSetHighRes();
bool lidarReadValue();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lidar.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
bool lidarInit() {
    // Initialize with PVAL0 high quality, PVAL1 standard quality, enable, no interrupt
    LIDAR_REG_CFG.field.PVAL0 = LIDAR_REG_CFG_PVAL.HQ;
    LIDAR_REG_CFG.field.PVAL1 = LIDAR_REG_CFG_PVAL.SQ;
    LIDAR_REG_CFG.field.EN    = LIDAR_REG_CFG_EN.ENABLE;
    LIDAR_REG_CFG.field.ITR   = LIDAR_REG_CFG_ITR.DISABLE;

    // Write the desired configuration to the appropraite register on the lidar
    if (!i2cWriteRegister(LIDAR_ADDR, LIDAR_REG_CFG_ADDR, LIDAR_REG_CFG)) {
        // Return if we failed
        return FALSE;
    }

    // Enable was a success, let&#39;s adjust the PVALs to finish
    LIDAR_REG_CFG.field.PVAL0 = LIDAR_REG_CFG_PVAL.MQ;
    LIDAR_REG_CFG.field.PVAL1 = LIDAR_REG_CFG_PVAL.HQ;

    return i2cWriteRegister(LIDAR_ADDR, LIDAR_REG_CFG_ADDR, LIDAR_REG_CFG);
}

bool lidarSetLowRes() {
    LIDAR_REG_CFG.field.PVAL0 = LIDAR_REG_CFG_PVAL.LQ;
    LIDAR_REG_CFG.field.PVAL1 = LIDAR_REG_CFG_PVAL.LQ;

    return i2cWriteRegister(LIDAR_ADDR, LIDAR_REG_CFG_ADDR, LIDAR_REG_CFG);
}

bool lidarSetHighRes() {
    LIDAR_REG_CFG.field.PVAL0 = LIDAR_REG_CFG_PVAL.HQ;
    LIDAR_REG_CFG.field.PVAL1 = LIDAR_REG_CFG_PVAL.HQ;

    return i2cWriteRegister(LIDAR_ADDR, LIDAR_REG_CFG_ADDR, LIDAR_REG_CFG);
}

bool lidarReadValue() {
    return i2cReadRegister(LIDAR_ADDR, LIDAR_BUF_VALUE_ADDR, LIDAR_BUF_VALUE.byte, 4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;auto.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;lidar.h&amp;quot;

void autonomous() {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pollingTask&#34;&gt;I2C Polling Tasks&lt;/h2&gt;

&lt;p&gt;A dedicated I2C polling task is necessary when using multiple I2C devices at once to ensure that they are all read properly. It is recommended that this task be run at a high priority (TASK_PRIORITY_DEFAULT + 2 should work well) to ensure that the task runs at very consistent intervals and it is never starved for processing resources. The I2C line updates at 4KHz in PROS, but it is typically unnecessary to read any faster than once per millisecond.&lt;/p&gt;

&lt;p&gt;The I2C polling task can be run like any other task. It is highly recommended that the &lt;code&gt;taskDelayUntil()&lt;/code&gt; function be used instead of &lt;code&gt;delay()&lt;/code&gt; to set the loop frequency to prevent even-odd jitter.&lt;/p&gt;

&lt;p&gt;i2cTask.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;third_party_gyro.h&amp;quot; //custom gyro

#define NUM_IMES 2 //using two IMEs on the robot
#define IME_LEFT 0
#define IME_RIGHT 1

#define CYCLE_TIME 2 //loop delay in milliseconds

volatile int32_t leftIME, rightIME;

static void i2cHandler(void* ignore) {  
  gyroInit(); //initialization for custom gyro
  int num_IMEs_initialized = imeInitializeAll();
  if (num_IMEs_initialized != NUM_IMES) {
    printf(&amp;quot;ERROR: INCORRECT NUMBER OF IMEs INITIALIZED\n&amp;quot;);
    break;
  }

  uint32_t now = millis();
  while(true) {
    gyroIntegrate(); //summing third party gyro&#39;s readings
    imeGet(IME_LEFT, &amp;amp;leftIME);
    imeGet(IME_RIGHT, &amp;amp;rightIME);

    taskDelayUntil(&amp;amp;now, CYCLE_TIME);
  }
}

void i2cTaskStart() {
  taskCreate(i2cHandler, TASK_DEFAULT_STACK_SIZE, NULL, (TASK_PRIORITY_DEFAULT + 2));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize() {
  i2cTaskStart();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;debugging-tips-and-tricks&#34;&gt;Debugging Tips and Tricks&lt;/h2&gt;

&lt;p&gt;As with most advanced topics, a lot of debugging is typically needed when working with the I2C bus, both for beginners and experienced users. It can sometimes be difficult to know where to start with debugging any issues that arise, but here are few good places to start looking.&lt;/p&gt;

&lt;h3 id=&#34;cortex-crashes&#34;&gt;Cortex Crashes&lt;/h3&gt;

&lt;p&gt;The Cortex&amp;rsquo;s I2C line is particularly vulnerable to static shock, which can cause the Cortex to reset or other undefined behavior. This issue is often seen when using IMEs, as they are typically used in locations on the robot that are prime candidates for static discharge from the field.&lt;/p&gt;

&lt;p&gt;To help prevent this issue, a watchdog is available with PROS to monitor the status of the Cortex and perform a reset in the case of a static shock. The watchdog is a feature that is implemented in the Cortex M3 chip itself, and PROS simply provides a wrapper for this.&lt;/p&gt;

&lt;p&gt;To enable the watchdog, it must be started in &lt;code&gt;initalizeIO()&lt;/code&gt;. Calling the watchdog anywhere else will not have an effect.&lt;/p&gt;

&lt;p&gt;init.c&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initializeIO() {
  watchdogInit();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sign-extension&#34;&gt;Sign Extension&lt;/h3&gt;

&lt;p&gt;It is very important to keep track of the size of the data being read from or written to your I2C device. Sign Extension occurs when casting a signed value with a smaller number of bytes to a signed value with a larger number of bytes. In this case, the sign bit is copied to all of the additional bits, which can cause readings to be different than their intended values.&lt;/p&gt;

&lt;h3 id=&#34;endianness&#34;&gt;Endianness&lt;/h3&gt;

&lt;p&gt;Endianness is the direction in which bytes are arranged when being output from a device. A device is either big-endian or little-endian, with these two options being the opposite of one another. A big-endian device will arrange bytes with the most significant (highest order) byte first, and little-endian arranges bytes with the least significant byte first. An example of reading a big-endian device can be found in &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/i2c/#readingI2CSlave&#34;&gt;Reading from an I2C Slave&lt;/a&gt;. If an I2C reading is an unexpected value, try reading in the opposite endianness.&lt;/p&gt;

&lt;h3 id=&#34;union-struct-method&#34;&gt;Union/Struct method&lt;/h3&gt;

&lt;p&gt;One solution to reading a collection of bits from a device is to use a struct wrapped in a union as seen in the &lt;code&gt;LIDAR_REG_CFG&lt;/code&gt; union in &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/i2c/#thirdPartyI2CDevices&#34;&gt;Third-Party I2C Devices&lt;/a&gt;. The union contains a value that contains the reading from the sensor, and the struct contains each significant bit as an individual value. Write to the union&amp;rsquo;s value, and then read individual bits from the struct. If you are not familiar with unions and structs, reading an &lt;a href=&#34;https://www.codingunit.com/c-tutorial-structures-unions-typedef&#34;&gt;Online C Tutorial&lt;/a&gt; about the subject is recommended.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JINX</title>
      <link>http://pros.cs.purdue.edu/tutorials/jinx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/jinx/</guid>
      <description>

&lt;div class=&#34;admonition warning&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;JINX is in Beta&lt;/p&gt;
&lt;p&gt;JINX is in active development and could change at any time. This document is
intended to introduce JINX to advanced PROS users who may wish to experiment with JINX.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;JINX is the graphical debugger and interactive data visualization tool for PROS. With JINX, you get to graph data, generate CSV files, send commands back to the cortex, and more, all from the browser of choice. JINX works by using a computer connected to the cortex via serial as the central hub enabling other computers and mobile devices on the network to connect as clients and enjoy the use of the interactive features.&lt;/p&gt;

&lt;p&gt;Before you can run JINX there are some required setup tasks.&lt;/p&gt;

&lt;h2 id=&#34;jinx-installation-requirements&#34;&gt;JINX Installation Requirements&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;Python 3.4.3+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pyserial.readthedocs.io/en/latest/pyserial.html&#34;&gt;pySerial 3.2.1+&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you have python3 installed on your machine you can easily install pySerial from the command line via:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip3 install pyserial&lt;/code&gt; or &lt;code&gt;pip3 install --upgrade pyserial&lt;/code&gt; to upgrade to the latest if a previous instance is already installed.&lt;/p&gt;

&lt;h2 id=&#34;jinx-installation&#34;&gt;JINX Installation&lt;/h2&gt;

&lt;p&gt;Release 0.1: &lt;a href=&#34;https://github.com/purduesigbots/JINX/releases/tag/v0.1&#34;&gt;https://github.com/purduesigbots/JINX/releases/tag/v0.1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;debugging-with-jinx&#34;&gt;Debugging with JINX&lt;/h2&gt;

&lt;p&gt;To utilize the power of JINX simply:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Connect your desired host computer to the VEX Cortex&lt;/li&gt;
&lt;li&gt;Upload JINX enabled code&lt;/li&gt;
&lt;li&gt;Start the JINX server on your host computer with &lt;code&gt;python3 JINX.py&lt;/code&gt;&lt;br /&gt;
You must run this command in the JINX directory for the server to work correctly.&lt;/li&gt;
&lt;li&gt;Navigate to the JINX Dashboard by connecting to &lt;code&gt;http://localhost:9001/views/combined.html&lt;/code&gt; on your host computer and watch the information flow&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If at any point in time you want to stop the JINX server simply type &lt;code&gt;q&lt;/code&gt; in the active terminal used to launch JINX or send a keyboard interrupt via &lt;code&gt;ctrl + c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:
Since JINX is a network application not everyone has to crowd around a single machine to observe the data feed. If you are on the same local network you can navigate to the IP address of the JINX host machine to get access to the dashboard as well. For example, if the IP address of the JINX host machine is &lt;code&gt;192.168.1.105&lt;/code&gt; you would navigate to &lt;a href=&#34;http://192.168.1.105:9001/views/combined.html&#34;&gt;http://192.168.1.105:9001/views/combined.html&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;initJINX&#34;&gt;initJINX&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initJINX ( FILE * port )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initializes and enables JINX on the specified port.&lt;br /&gt;
This should be called in &lt;code&gt;initialize()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This call prints an error message over stdout if unable to initialize and set port.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Parameters&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;port&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;the port to open, either stdout, UART1, or UART2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;writeJINXSerial&#34;&gt;writeJINXSerial&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void writeJINXSerial ( const char *  message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sends a simple string to the JINX host with appropriate header and terminator.&lt;/p&gt;

&lt;p&gt;This function only takes one character pointer, and does &lt;strong&gt;not&lt;/strong&gt; work like &lt;code&gt;printf()&lt;/code&gt;. Therefore, it is advised that users calling this function directly use &lt;code&gt;sprintf(char \*src, const char \*formatString, ...)&lt;/code&gt; to compose their message before calling this.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Parameters&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;message&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The message to send&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;writeJINXData&#34;&gt;writeJINXData&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void writeJINXData ( const char *  name
const char *  value
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sends a name/value pair of data to to the JINX host.&lt;/p&gt;

&lt;p&gt;If &lt;code&gt;value&lt;/code&gt; is strictly numeric (as defined by javascript&amp;rsquo;s &lt;code&gt;isNaN&lt;/code&gt; then the variable can be graphed. Otherwise, the name/value pair will be displayed in the terminal.&lt;/p&gt;

&lt;p&gt;This function does not allow for string formatting. Therefore, it is advised that users calling this function directly use &lt;code&gt;sprintf(char \*src, const char \*formatString, ...)&lt;/code&gt; to compose both &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; before calling this.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Parameters&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The identifier key sent to the GUI.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The value to be graphed or displayed in the GUI&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;writeJINXMessage&#34;&gt;writeJINXMessage&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void writeJINXMessage ( const char *  message )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simple wrapper function for &lt;code&gt;writeJINXData&lt;/code&gt; with &lt;code&gt;name&lt;/code&gt; as &amp;ldquo;msg&amp;rdquo; and &lt;code&gt;value&lt;/code&gt; set to &lt;code&gt;message&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;Parameters&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;&lt;code&gt;message&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The message to send&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;JINX_Reader&#34;&gt;JINX Reader&lt;/h2&gt;

&lt;p&gt;The read task is started by calling&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;taskCreate(JINXRun, TASK_DEFAULT_STACK_SIZE, NULL, (TASK_PRIORITY_DEFAULT));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in &lt;code&gt;initialize()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;parseMessage&#34;&gt;parseMessage&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void parseMessage ( JINX *  inStr )  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Automatically called by whenever a message is sent to the cortex. The user should implement the body of this function to call their method of choice based on the incoming message. See below for an example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//Example parse. User can and should replace with own body.
void parseMessage(JINX * inStr) {
  //Echo entire recieved message
  writeJINXMessage(inStr-&amp;gt;command);
  //Set inStr-&amp;gt;token to first token (space-delimated word)
  getToken(inStr, 0);   

  if (strcmp(inStr-&amp;gt;token, &amp;quot;Option_1&amp;quot;) == 0) {
    //Do option 1
    writeJINXMessage(&amp;quot;Option 1 chosen.&amp;quot;);
  } else if(strcmp(inStr-&amp;gt;token, &amp;quot;get&amp;quot;) == 0) {
    //Call another function to handle &amp;quot;get&amp;quot;
    handleGet(inStr);
  } else {
    //Do default
    writeJINXMessage(&amp;quot;No comparison found&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;handleGet()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;  //Example of user defined JINX helper function.  
  //Since it is at the top of this file, it can be called from anywhere   else in this file.  
  //Good practice is to put its prototype in JINX.h, though.  
  void handleGet(JINX * inStr) {  
  //Get the first token from the sent command  
  getToken(inStr, 1);

  //Host outgoing messages
  char * message = (char *)malloc(sizeof(char) * (strlen(inStr-&amp;gt;token) + 30));
  if (strcmp(inStr-&amp;gt;token, &amp;quot;DEBUG_JINX&amp;quot;) == 0) {
    writeJINXMessage(&amp;quot;Asked for Debug&amp;quot;);
    sprintf(message, &amp;quot;%s, %d&amp;quot;, inStr-&amp;gt;token, DEBUG_JINX);
  } else {
    sprintf(message, &amp;quot;%s %s&amp;quot;, inStr-&amp;gt;token, &amp;quot; was unable to be gotten.&amp;quot;);
  }

  //Free malloc&#39;d string
  writeJINXMessage(message);
  free(message);
  message = NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getToken&#34;&gt;getToken&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int getToken ( JINX *  inStr
  int     tokenNum
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sets &lt;code&gt;inStr-&amp;gt;token&lt;/code&gt; to the &lt;code&gt;tokenNum&lt;/code&gt;th + 1 space-delimated word within &lt;code&gt;inStr-&amp;gt;command&lt;/code&gt;
&lt;code&gt;tokenNum&lt;/code&gt; is 0-based, so 0 will get the 1st token, 1 will get the 2nd token&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LCD Screen</title>
      <link>http://pros.cs.purdue.edu/tutorials/lcd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/lcd/</guid>
      <description>&lt;p&gt;The LCD screen communicates to the Cortex Microcontroller via a UART cable. This communication needs to be initialized in &lt;code&gt;init.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize() {
  // ...
  // Select &amp;quot;uart1&amp;quot; or &amp;quot;uart2&amp;quot; as appropriate
  lcdInit(uart1);
  lcdClear(uart1);
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in any function you can do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//...
// Print formatted text to LCD (line #1) like printf
// supposing that &amp;quot;x&amp;quot; is an existing integer variable
lcdPrint(uart1, 1, &amp;quot;X is %d&amp;quot;, x);
// Print plain text to LCD (much faster than lcdPrint)
lcdSetText(uart1, 2, &amp;quot;Hello World&amp;quot;);
// Print current battery voltage
lcdPrint(uart1, 1, &amp;quot;Batt: %1.3f V&amp;quot;, (double)powerLevelMain() / 1000);
// ...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pneumatics</title>
      <link>http://pros.cs.purdue.edu/tutorials/pneumatics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/pneumatics/</guid>
      <description>&lt;p&gt;Pneumatics in VEX provide two-state linear actuation. They differ from other
digital sensors in that they are output signals. Therefore, the default digital
sensor configuration is insufficient.&lt;/p&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initializeIO() {
  pinMode(1, OUTPUT); // configure digital port 1 as an output
  digitalWrite(1, LOW); // write LOW to port 1 (solenoid may be extended or not, depending on wiring)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c, auto.c, etc.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFunction() {
  // ...
  digitalWrite(1, new_value); // write HIGH or LOW to port 1 in place of new_value
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Programming the Clawbot</title>
      <link>http://pros.cs.purdue.edu/tutorials/clawbot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/clawbot/</guid>
      <description>

&lt;h4 id=&#34;objective&#34;&gt;Objective:&lt;/h4&gt;

&lt;p&gt;This tutorial will guide you through basic programming of the VEX Clawbot.&lt;/p&gt;

&lt;h4 id=&#34;intended-audience&#34;&gt;Intended Audience:&lt;/h4&gt;

&lt;p&gt;This tutorial is intended for developers with some programming experience, but with little to no experience with the PROS library. If you haven&amp;rsquo;t programmed before, we recommend checking out all the &amp;ldquo;Introduction and Basic C Features&amp;rdquo; sections of &lt;a href=&#34;Introduction and Basic C Features&#34;&gt;this tutorial series&lt;/a&gt;; you may also benefit from the &amp;ldquo;Pointers, Arrays and Strings&amp;rdquo; sections as well (although they aren&amp;rsquo;t as pertintent).&lt;/p&gt;

&lt;h4 id=&#34;goals&#34;&gt;Goals:&lt;/h4&gt;

&lt;p&gt;At the end of this tutorial you will have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Understood the basic project structure of PROS&lt;/li&gt;
&lt;li&gt;Programmed a basic chassis with &amp;ldquo;tank&amp;rdquo; control or &amp;ldquo;arcade&amp;rdquo; control&lt;/li&gt;
&lt;li&gt;Programmed buttons to control the clawbot&amp;rsquo;s lift&lt;/li&gt;
&lt;li&gt;Programmed a joystick axis to control the clawbot&amp;rsquo;s claw&lt;/li&gt;
&lt;li&gt;Understood the standard subsystem module methodology&lt;/li&gt;
&lt;li&gt;Programmed a dead-reckoned autonomous routine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here&amp;rsquo;s the robot we&amp;rsquo;ll be programming:

&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/tuts/clawbot1.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;For the purposes of this tutorial, we&amp;rsquo;ve plugged in our motors into the following ports:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Port&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Port&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Left wheels&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Right wheels&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Lift&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Claw&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We modified our clawbot to include a quadrature encoder on the lift arm. We plugged the top and bottom ports into digital ports 2 and 3, respectively.&lt;/p&gt;

&lt;p&gt;With Atom started, you can create a new PROS project by clicking the &lt;code&gt;PROS&lt;/code&gt; menu, then click &lt;code&gt;Create new Project&lt;/code&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/menu-create-new.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Create a directory that you&amp;rsquo;d like to keep the source files for your Clawbot project. We&amp;rsquo;re creating ours in &lt;code&gt;C:\Users\Elliot\dev\Clawbot&lt;/code&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/window-create-new.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Pick a directory to create the new project in and click Create. The PROS CLI will now copy the latest kernel template into the specified directory and Atom will open it.

&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/proj-brand-new.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;pros-project-structure&#34;&gt;PROS Project Structure&lt;/h2&gt;

&lt;p&gt;When you create your project, PROS will copy all of the files necessary to build your project. The structure of the project looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;project
│   project.pros        (used by PROS CLI to know kernel version and other metadata)
│   Makefile            (instructs make how to compile your project)
|   common.mk           (helper file for Makefile)
│
└───src                 (source files should go here)
│   │   auto.c          (source for autonomous function)
│   │   init.c          (source for initialization)
│   │   opcontrol.c     (source for operator control)
│   │   Makefile        (instructs make how to compile your source files)
|
└───include             (Header files should go in here)
│   │   API.h           (Lets source files know PROS API functions)
│   │   main.h          (Includes API.h and anything else you want to include project-wide)
│   
└───firmware
    │   cortex.ld       (Instructs the linker how to construct binaries for the Cortex)
    │   libpros.a       (Pre-compiled PROS library)
    |   STM32F10x.ld    (Instructs the linker how to construct binaries for the Cortex)
    |   uniflash.jar    (Legacy flashing utility built w/Java)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Convention Awareness&lt;/p&gt;
&lt;p&gt;By convention, the &lt;code&gt;opcontrol()&lt;/code&gt;, &lt;code&gt;autonomous()&lt;/code&gt;, and initialize functions are separated into separate files (opcontrol.c, auto.c, and init.c). They could be all in the same file, but it can be helpful to organize your functions into multiple files to keep things from becoming messy.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;arcade-control&#34;&gt;Arcade Control&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s begin by writing a basic &amp;ldquo;arcade&amp;rdquo; control for the clawbot. In arcade control, the vertical joystick values control the forward/backward speed of the robot and the horizontal joystick values control the rotation of the robot. Atom will open&lt;code&gt;src/opcontrol.c&lt;/code&gt; for you when you create a project, but if it is not open then you will need to open it by navigating the directory tree on the left panel.&lt;/p&gt;

&lt;p&gt;The template &lt;code&gt;opcontrol.c&lt;/code&gt; file contains a simple infinite loop and documentation to help remind you what &lt;code&gt;opcontrol()&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;PROS offers functions to perform common tasks associated with programming robotics. To program basic arcade functionality, we need to be aware of two functions: one to get the joystick input and one to set the motors to a speed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int joystickGetAnalog ( unsigned char joystick,   // the joystick slot to check (1 for master, 2 for partner)
                        unsigned char axis        // One of the joystick channels on a VEX Joystick: 1, 2, 3, 4, ACCEL_X, or ACCEL_Y
                      );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gets the value of a control axis on the VEX joystick.
&lt;em&gt;&lt;strong&gt;Returns&lt;/strong&gt; the value from -127 to 127, or 0 if no joystick is connected to the requested slot.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void motorSet ( unsigned char channel,  // motor channel to set from 1-10
                int speed               // new signed speed. -127 is full reverse, 127 full forward, 0 off
              );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sets the speed of the specified motor channel.&lt;/p&gt;

&lt;p&gt;Armed with knowledge of these functions, let&amp;rsquo;s modify &lt;code&gt;opcontrol()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void operatorControl() {
  int power;
  int turn;
    while (1) {
        power = joystickGetAnalog(1, 2); // vertical axis on left joystick
        turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
        motorSet(2, power + turn); // set left wheels
        motorSet(3, power - turn); // set right wheels
        delay(20);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Commenting Code&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s considered good practice to comment your code. Commenting can make it easier to understand the original intention of code when you have to look back on it months later in the middle of the competition and everything&amp;rsquo;s broken.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your code should tell the story of what you are doing; your comments should tell the story of why you are doing it.
&lt;em&gt;(Source: &lt;a href=&#34;http://stackoverflow.com/a/142869&#34;&gt;http://stackoverflow.com/a/142869&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;compilation&#34;&gt;Compilation&lt;/h2&gt;

&lt;p&gt;Next, you will need to &lt;strong&gt;compile&lt;/strong&gt; your project. Compilation converts your code into instructions the Cortex can understand. There are typically four stages to compilation. The following paragraphs explain abstract complicated technical systems. This introduction to compilation is intended to give some justification for the compilation process, but is by no means complete. &lt;strong&gt;This information is not necessary to program with PROS, but may be helpful for some.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1. Preprocessing&lt;/p&gt;

&lt;p&gt;Lines starting with a &lt;code&gt;#&lt;/code&gt; are interpreted by the preprocessor as commands. These commands can include other pieces of files (&lt;code&gt;#include&lt;/code&gt;), execute basic macro logic (&lt;code&gt;#ifdef&lt;/code&gt;), replace text (&lt;code&gt;#define&lt;/code&gt;), and more. The goal of preprocessing is to reduce duplicated code.&lt;/p&gt;

&lt;p&gt;For instance, to call the PROS API, all of the &lt;em&gt;function declarations&lt;/em&gt; need to go in the source file. Using a &lt;em&gt;header file&lt;/em&gt; can simplify this operation by writing all of the function declarations in one place, and just &lt;code&gt;#include&lt;/code&gt;-ing it to reference those function declarations.&lt;/p&gt;

&lt;p&gt;2. Compilation&lt;/p&gt;

&lt;p&gt;The next stage of compilation is to translate preprocessed code into &lt;em&gt;assembly instructions&lt;/em&gt; that the ARM Cortex-M3 processor can almost understand. Assembly code is human readable and reasonably converted into a language that the processor can understand.&lt;/p&gt;

&lt;p&gt;3. Assembly&lt;/p&gt;

&lt;p&gt;The assembler translates assembly instructions directly into machine code (called &lt;em&gt;object code&lt;/em&gt; or &lt;em&gt;objects&lt;/em&gt;). These files aren&amp;rsquo;t considered human readable and can be interpreted by the processor directly.&lt;/p&gt;

&lt;p&gt;4. Linking&lt;/p&gt;

&lt;p&gt;The final stage of compilation is linking. Objects contain pieces of machine instructions, but may not be complete. For instance, when compiling your source files, the PROS API are not directly incorporated into your object code (merely references to the PROS API functions, as specified by the function declarations). The Linker will incorporate and rearrange all the difference object files (and libraries) into one file that &lt;em&gt;can&lt;/em&gt; be interpreted by the processor.&lt;/p&gt;

&lt;p&gt;To compile code within Atom, press &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt; to bring up the Command Palette. You can start typing the command you wish to execute, &amp;ldquo;Build: Trigger&amp;rdquo;. You should also notice that it will display the available shortcut keys to execute the command. By default, triggering a build can be done by pressing &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt; (&lt;code&gt;⌘&lt;/code&gt;+&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt;) or &lt;code&gt;F9&lt;/code&gt;. If you have unsaved files, Build will prompt you to save those files. You should always save before building.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/build.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;uploading&#34;&gt;Uploading Code to the Cortex&lt;/h2&gt;

&lt;p&gt;Now that you have compiled a binary file that the Cortex can understand, you need to upload it to the microcontroller. Within Atom, click the &amp;lsquo;Upload to Cortex&amp;rsquo; button in Atom. This process will upload the binary the compilation process created (&lt;code&gt;bin/output.bin&lt;/code&gt;) to the Cortex and begin running it.&lt;/p&gt;

&lt;p&gt;If you followed these instructions correctly, you can connect a joystick to the clawbot and drive it using arcade controls!&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/upload.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;subsystem-methodology&#34;&gt;Subsystem Module Methodology&lt;/h2&gt;

&lt;p&gt;In this section, we&amp;rsquo;ll introduce the subsystem module methodology. When developing code for complicated robotic systems, it&amp;rsquo;s extremely helpful to abstract away the necessary steps to perform actions on a system. For instance, to set the speed of a 4 motor chassis, you may need to set the speed of the front left motor, the rear left motor, and so on. You might just have four &lt;code&gt;motorSet()&lt;/code&gt; calls every time you want to set robot&amp;rsquo;s speed, but what happens when you add another pair of motors to your chassis, or collapse your left and right sides onto two Y-cables? You would need to comb through all of your code to find all of the times you set the chassis speeds and adjust those calls accordingly. Similarly, you may want a level of abstraction for getting sensor values - what happens if you decide to switch from quadrature encoders to integrated motor encoders?&lt;/p&gt;

&lt;p&gt;Writing a function such as &lt;code&gt;chassisSet()&lt;/code&gt; can help mitigate this problem. Additionally, you cannot write your &lt;code&gt;chassisSet()&lt;/code&gt; function in multiple source files, so you need to create a single source file and be able to incorporate it with &lt;code&gt;opcontrol.c&lt;/code&gt;, &lt;code&gt;init.c&lt;/code&gt;, and &lt;code&gt;auto.c&lt;/code&gt;. The subsystem module methodology is a standard way of organizing these sorts of functions. We define a subsystem as a major component of a robot: chassis, lift, intake, and claw are some common subsystems. We&amp;rsquo;ll write our abstracted subsystem functions in a file like &lt;code&gt;src/chassis.c&lt;/code&gt; and put our function declarations in &lt;code&gt;include/chassis.h&lt;/code&gt; so that way we can call our new functions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s modify our existing operator control to use the subsystem methodology. We&amp;rsquo;ll begin by creating the header file containing our function declarations. You can create a new file in the &lt;code&gt;include&lt;/code&gt; directory by right clicking &lt;code&gt;include&lt;/code&gt; and clicking &amp;ldquo;New File&amp;rdquo;. We&amp;rsquo;ll name our file &lt;code&gt;chassis.h&lt;/code&gt;. A new empty file is created for us. Header files contain declarations, but not typically definitions. They are a way to describe what resources are available to you.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your own header files contain declarations for interfaces between the source files of your program. Each time you have a group of related declarations and macro definitions all or most of which are needed in several different source files, it is a good idea to create a header file for them. &lt;em&gt;(&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html&#34;&gt;GNU&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef _CHASSIS_H_
#define _CHASSIS_H_

// Sets the speeds of the left and right wheels of the chassis
void chassisSet(int left, int right);

#endif // _CHASSIS_H_
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;    // includes API.h and other headers
#include &amp;quot;chassis.h&amp;quot; // redundant, but ensures that the corresponding header file (chassis.h) is included

void chassisSet(int left, int right) {
  motorSet(2, left);
  motorSet(3, right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this methodology, we can rewrite our operator control to something much more concise:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;
#include &amp;quot;chassis.h&amp;quot;

void opcontrol() {
  while(1) {
    int power, turn;
    while (1) {
      power = joystickGetAnalog(1, 2); // vertical axis on left joystick
      turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
      chassisSet(power + turn, power - turn);
      delay(20);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be clear that congregating similar pieces of code into a C source file and a header file for other source files simplifies and organizes your code.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Reduce even more&lt;/p&gt;
&lt;p&gt;You can modify &lt;code&gt;main.h&lt;/code&gt; and include your own header files. In our example, we could modify our &lt;code&gt;main.h&lt;/code&gt; to look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// top of main.h omitted
#ifndef MAIN_H_

// This prevents multiple inclusion, which isn&#39;t bad for this file but is good practice
#define MAIN_H_

#include &amp;lt;API.h&amp;gt;
#include &amp;quot;chassis.h&amp;quot; // Added this line

// rest of main.h omitted from this listing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in &lt;code&gt;opcontrol.c&lt;/code&gt;, the only file we would need to &lt;code&gt;#include&lt;/code&gt; is &lt;code&gt;main.h&lt;/code&gt;. In future source files, we would only ever need to &lt;code&gt;#include &amp;quot;main.h&amp;quot;&lt;/code&gt; in order to get access to all of our robot&amp;rsquo;s subsystems&amp;rsquo; functions!&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;claw&#34;&gt;Programming the VEX Claw&lt;/h2&gt;

&lt;p&gt;We now want to use the left horizontal joystick to control the aperture of the claw. We&amp;rsquo;ll continue using the modular methodology:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;include/claw.h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef _CLAW_H_
#define _CLAW_H_

void clawSet(int speed);

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/claw.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;
#include &amp;quot;claw.h&amp;quot;

void clawSet(int speed) {
  motorSet(9, -speed);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/opcontrol.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void operatorControl() {
  int power, turn;
    while (1) {
    power = joystickGetAnalog(1, 2); // vertical axis on left joystick
    turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
    chassisSet(power + turn, power - turn);

    // add the following line:
    clawSet(joystickGetAnalog(1, 4));

    delay(20);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lift&#34;&gt;Controlling the Lift&lt;/h2&gt;

&lt;p&gt;Our drivers requested that they be able to use the trigger buttons to control the lift. At this point, complete the lift submodule on your own just like we did for the chassis and claw. If you&amp;rsquo;re having trouble, take a look at the complete Clawbot code sample at the bottom of this page.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/opcontrol.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void operatorControl() {
  int power, turn;
    while (1) {
    power = joystickGetAnalog(1, 2); // vertical axis on left joystick
    turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
    chassisSet(power + turn, power - turn);

    clawSet(joystickGetAnalog(1, 4));

    // add the following logic:
    if(joystickGetDigital(1, 6, JOY_UP)) {
      liftSet(127); // pressing up, so lift should go up
    }
    else if(joystickGetDigital(1, 6, JOY_DOWN)) {
      liftSet(-127); // pressing down, so lift should go down
    }
    else {
      liftSet(0); // no buttons are pressed, stop the lift
    }

    delay(20);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on your motor, you may notice that the arm falls back down when stopped mid-raise. This can be alleviated by applying some power to the motor when no buttons are pressed (instead of 0), or by using a feedback control system such as PID.&lt;/p&gt;

&lt;p&gt;-Congratulations, you have completed your first PROS program!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Project Structure</title>
      <link>http://pros.cs.purdue.edu/tutorials/project-structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/project-structure/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;PROS projects are internally composed of three parts: the &lt;em&gt;user code&lt;/em&gt;, the PROS &lt;em&gt;library&lt;/em&gt; and the &lt;em&gt;header&lt;/em&gt; files.&lt;/p&gt;

&lt;p&gt;The PROS library is a single file containing the core PROS routines. This file does not need to be changed. If there appears to be an issue with a core PROS function, please file an issue on &lt;a href=&#34;https://github.com/purduesigbots/pros/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;header&lt;/em&gt; files are all found in the &lt;code&gt;include&lt;/code&gt; directory. One header file, &lt;a href=&#34;http://pros.cs.purdue.edu/api/&#34;&gt;API.h&lt;/a&gt;, is required to declare the PROS library functions, and also serves as a quick reference. The other file, &lt;code&gt;main.h&lt;/code&gt;, is intended for declaring functions and variables shared between the user code files. New header files can be created in the include directory, as long as the name ends with .h.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;User code&lt;/code&gt; has the actual sequential instructions that govern the robot&amp;rsquo;s behavior. PROS by default splits the user code up into autonomous (&lt;code&gt;auto.c&lt;/code&gt;), driver control (&lt;code&gt;opcontrol.c&lt;/code&gt;), and initialization (&lt;code&gt;init.c&lt;/code&gt;) files. Code in one file can talk to code in another file using declarations in the header files. New user code files can be created in the &lt;code&gt;src&lt;/code&gt; directory, as long as the name ends with .c it will be compiled with the others.&lt;/p&gt;

&lt;p&gt;All user code files should start with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will ensure that the PROS API and other critical definitions are available in each file.&lt;/p&gt;

&lt;p&gt;While more complicated than some environments, splitting up code grants powerful modularity and code reusability, especially when combined with source control.&lt;/p&gt;

&lt;h2 id=&#34;declaring-functions-and-variables&#34;&gt;Declaring Functions and Variables&lt;/h2&gt;

&lt;p&gt;Functions and variables must be declared before use. Functions and variables can be declared in the typical C manner:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int sensorValue;

void DoIt(int x) {
   motorSet(5, x);
}

int getSensorValue(void) {
     DoIt(127);
     return sensorValue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doing so will make the variables and functions local to the file in which they exist.&lt;/p&gt;

&lt;p&gt;Some functions and variables are useful in more than one location (e.g. a function to use &lt;a href=&#34;http://pros.cs.purdue.edu/api/#motorset&#34;&gt;motorSet&lt;/a&gt; on all the robot&amp;rsquo;s drive motors with the same value). Such functions can be declared in any of the three files (or a custom file in the &lt;code&gt;src&lt;/code&gt; directory). To make them accessible to any other user code file, prototype the function in &lt;code&gt;main.h&lt;/code&gt; or in another header file.&lt;/p&gt;

&lt;p&gt;Functions can be prototyped by copying the function&amp;rsquo;s declaration line into &lt;code&gt;main.h&lt;/code&gt; and replacing the function code with &lt;code&gt;;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Prototype the &amp;quot;getSensorValue()&amp;quot; function declared above (in main.h)
int getSensorValue(void);

// Prototype the &amp;quot;DoIt()&amp;quot; function declared above (in main.h)
void DoIt(int x);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For pieces of code intended for frequent reuse, it may be better to create a separate header file with the related declarations, and to include that file in main.h. Therefore, large pieces of code involving look-up tables, control algorithms, or other complex structures can be quickly ported between projects by copying one .c user code file and one .h header file.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tasks and Multithreading</title>
      <link>http://pros.cs.purdue.edu/tutorials/tasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/tasks/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Tasks are a great tool to do multiple things at once, but they can be difficult
to use properly. Each task has a &lt;em&gt;priority&lt;/em&gt; and a &lt;em&gt;stack size&lt;/em&gt;. The higher the
priority, the more crucial the task is considered, and more CPU time will be
awarded to the task. Tasks of higher priority will &lt;em&gt;always&lt;/em&gt; run in preference to
lower priority tasks, unless the higher priority task is using &lt;code&gt;delay()&lt;/code&gt; or some
other waiting action.&lt;/p&gt;

&lt;p&gt;Tasks are creating using &lt;code&gt;taskCreate()&lt;/code&gt;, which invokes a user function in the new
task:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFirstTask(void * parameter) {
  while(true) {
    printf(&amp;quot;Hello from another task!\n&amp;quot;);
    delay(500);
  }
}

void initialize() { // or some other function
  TaskHandle firstTaskHandle = taskCreate(myFirstTask, TASK_DEFAULT_STACK_SIZE, NULL, TASK_PRIORITY_DEFAULT);
  delay(20000); // or doing anything else
  taskDelete(firstTaskHandle); // stop running the task
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;periodic-functions&#34;&gt;Periodic functions&lt;/h3&gt;

&lt;p&gt;If you want a function to run every &lt;em&gt;n&lt;/em&gt; milliseconds, you can use &lt;code&gt;taskRunLoop&lt;/code&gt;.
The example above can be implemented slightly differently and receive the same effect:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void myFirstRunLoop() {
  printf(&amp;quot;Hello from another task!\n&amp;quot;);
}

void initialize() {
  TaskHandle secondTaskHandle = taskRunLoop(myFirstRunLoop, 500);
  delay(20000); // or doing anything else
  taskDelete(secondTaskHandle);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;best-task-practices&#34;&gt;Best Task Practices&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Limit the number of tasks; five medium sized tasks will run quicker than ten tiny ones. There is also a limit of twelve tasks running at once.&lt;/li&gt;
&lt;li&gt;Tasks are usually not automatically stopped if the robot is disabled, unlike &lt;code&gt;operatorControl&lt;/code&gt; and &lt;code&gt;autonomous&lt;/code&gt;. Tasks running while disabled cannot use the VEX Joystick or VEX Motors. If the task should stop when the robot is disabled, use the &lt;code&gt;isOnline&lt;/code&gt; and/or the &lt;code&gt;isAutonomous&lt;/code&gt; function to control the program accordingly. If &lt;code&gt;taskRunLoop&lt;/code&gt; is used, the task will automatically be cancelled if the robot is disabled or switched between driver and autonomous.&lt;/li&gt;
&lt;li&gt;Most tasks should have a priority from &lt;code&gt;TASK_PRIORITY_LOWEST + 1&lt;/code&gt; to &lt;code&gt;TASK_PRIORITY_HIGHEST - 1&lt;/code&gt;. Tasks of the lowest or highest priority may cause unexpected behavior.&lt;/li&gt;
&lt;li&gt;Tasks should wait when there is no work to do so other tasks can run. If a task, especially a high-priority one, does not occasionally use delay or similar, other tasks may not run or run very slowly. Since hardware such as the VEX LCD and Integrated Motor Encoders is also updated by tasks, a run away task can cause unexpected behavior.&lt;/li&gt;
&lt;li&gt;The Cortex Microcontroller is very fast. It is unlikely that any repetitive task will gain from running continuously. Even in the fastest scenarios, &lt;code&gt;delay(2)&lt;/code&gt; will probably make no noticable difference, but will prevent future task starvation issues.&lt;/li&gt;
&lt;li&gt;Tasks using motors or joysticks should use &lt;code&gt;delay(20)&lt;/code&gt; as the motors and joysticks are only updated every 20 ms.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;synchronization&#34;&gt;Synchronization&lt;/h2&gt;

&lt;p&gt;One problem which one often runs into when dealing with tasks is the problem of
synchronization. If two tasks try to read the same sensor or control the same
motor at the same time, unexpected behavior may occur since two tasks are trying
to read/write to the same piece of data.&lt;/p&gt;

&lt;p&gt;Tasks can be designed to never conflict over motors or sensors: (division of responsibility)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Task1(void * ignore) {
  // update motors 2 and 4
}

void Task2(void * ignore) {
  // update motors 5 and 6
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes this is impossible: suppose you wanted to write a PID controller on its own task and
you wanted to change the target of the controller. PROS features two types of synchronization
structures, &lt;em&gt;mutexes&lt;/em&gt; and &lt;em&gt;semaphores&lt;/em&gt; that can be used to coordinate tasks. Mutexes stand for
mutual exclusion; only one task can hold a mutex at any given time. Other tasks must wait for the
first task to finish (and release the mutex) before they may continue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Mutex mutex = mutexCreate();

// Acquire the mutex; other tasks using this command will wait until the mutex is released
// timeout can specify the maximum time to wait, or MAX_DELAY to wait forever
// If the timeout expires, &amp;quot;false&amp;quot; will be rturned, otherwise &amp;quot;true&amp;quot;
mutexTake(mutex, timeout);
// do some work
// Release the mutex for other tasks
mutexGive(mutex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Semaphores are like signals - one task can take a semaphore to wait for a coordination signal
from another task which gives the semaphore. Multiple tasks may wait for a semaphore; if this
is the case, the highest priority task will continue per signal given.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Create a semaphore
Semaphore semaphore = semaphoreCreate();

// Waits for the semaphore to be signalled
// timeout can specify the maximum time to wait, or MAX_DELAY to wait forever
// If the timeout expires, &amp;quot;false&amp;quot; will be rturned, otherwise &amp;quot;true&amp;quot;
semaphoreTake(semaphore);
// do something
// Signal the semaphore
semaphoreGive(semaphore);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Tutorials</title>
      <link>http://pros.cs.purdue.edu/tutorials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/</guid>
      <description>&lt;p&gt;Learning a new coding platform is often a rather daunting task. For this reason we prepared some small tutorials with examples on how to interact with core components of PROS on your VEX Cortex. Select from the menu on the left to learn about everything from &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/analog&#34;&gt;analog sensors&lt;/a&gt; to &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/tasks&#34;&gt;tasks/multithreading&lt;/a&gt; and communicating with 3rd party sensors via &lt;a href=&#34;http://pros.cs.purdue.edu/tutorials/i2c&#34;&gt;I2C&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ultrasonic Sensors</title>
      <link>http://pros.cs.purdue.edu/tutorials/ultrasonic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/ultrasonic/</guid>
      <description>&lt;p&gt;The ultrasonic sensor enables robots to measure distance. Ultrasonic sensors accomplish
by taking advantage of echoes. Sound echoes off of most materials and speed travels at a
reasonably consistent speed, so measuring the amount of time for the sound to be transmitted
and received measures the distance away from an object. Ultrasonic sensors, not surprisingly,
use ultrasonic pings to determine distance. Sensors that measure the amount of time for a
signal to echo back are called Time of Flight sensors (ToF).&lt;/p&gt;

&lt;p&gt;VEX Ultrasonic sensors use two digital signals: one to produce the ultrasonic ping, and one to
detect the response. The &amp;ldquo;echo&amp;rdquo; port is labeled by the cable with an orange wire. The &amp;ldquo;ping&amp;rdquo;
port is determined by the cable with a yellow wire.&lt;/p&gt;

&lt;p&gt;PROS provides an ultrasonic library to automatically send out pulses and determine how long the
response takes.&lt;/p&gt;

&lt;p&gt;main.h:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;Ultrasonic sonar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init.c:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void initialize() {
  // ...
  sonar = ultrasonicInit(orange_port_number, yellow_port_number);
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;opcontrol.c, auto.c, etc.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void myFunction() {
  // ...
  // Get ultrasonic reading in centimeters
  int distance = ultrasonicGet(sonar);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Upgrading PROS Projects</title>
      <link>http://pros.cs.purdue.edu/tutorials/upgrading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://pros.cs.purdue.edu/tutorials/upgrading/</guid>
      <description>

&lt;h2 id=&#34;hey-i-heard-there-was-a-new-release-of-the-pros-kernel-how-do-i-upgrade-my-project&#34;&gt;Hey! I heard there was a new release of the PROS kernel&amp;ndash; How do I upgrade my project?&lt;/h2&gt;

&lt;p&gt;Never fear, you&amp;rsquo;ve come to the right place.&lt;/p&gt;

&lt;h3 id=&#34;downloading-the-new-version&#34;&gt;Downloading the new version&lt;/h3&gt;

&lt;p&gt;The first step in this process is to acquire a physical copy of the kernel. Don&amp;rsquo;t worry, it&amp;rsquo;s easier than it sounds.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Terminology&lt;/p&gt;
&lt;p&gt;From now on, this tutorial will specify keypress commands in the form &lt;code&gt;CTRL&lt;/code&gt;-&lt;code&gt;SHIFT&lt;/code&gt;-&lt;code&gt;P&lt;/code&gt;. On macOS, the equivalent command is &lt;code&gt;⌘&lt;/code&gt;+&lt;code&gt;SHIFT&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;, so for the rest of this tutorial, assume that &lt;code&gt;CTRL&lt;/code&gt; refers to &lt;code&gt;⌘&lt;/code&gt; unless otherwise specified.&lt;/p&gt;
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;In Atom, type &lt;code&gt;CTRL&lt;/code&gt;+&lt;code&gt;SHIFT&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;, and then start typing &amp;lsquo;conductor&amp;rsquo;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/open-conductor.png&#34; /&gt;
    
    
&lt;/figure&gt;

2. A nice tab like this will appear:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/conductor-gui.png&#34; /&gt;
    
    
&lt;/figure&gt;

3. In the &amp;lsquo;Global Configuration&amp;rsquo; section, under &amp;lsquo;Kernels,&amp;rsquo; there is a list:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/conductor-gui-zoom.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The latest version of the kernel appears at the top of the list, and the versions you have available to use have the small computer icon to the right of the version number.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To download the latest version, click the small cloud icon on the far right of the version number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Once the download has completed, a green balloon will pop up informing you as such.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/download-complete.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;If you don&amp;rsquo;t have any old projects to upgrade, you&amp;rsquo;re done! New projects will be created, by default, with the latest version of the kernel you have locally.&lt;/p&gt;

&lt;h3 id=&#34;but-i-have-old-projects-that-need-to-get-upgraded&#34;&gt;But I have old projects that need to get upgraded!&lt;/h3&gt;

&lt;p&gt;Alright, here&amp;rsquo;s how:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Up on the menu bar in Atom, select &lt;code&gt;PROS&lt;/code&gt;&amp;gt;&lt;code&gt;Upgrade a PROS Project&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/upgrade-menu.png&#34; /&gt;
    
    
&lt;/figure&gt;

2. A new dialog will appear, asking you to select the project folder and the kernel version:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/upgrade-project.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Note that choosing &amp;lsquo;Auto-select latest&amp;rsquo; in the dropdown will do the same thing as manually selecting the latest version (as it is shown in the screenshot above).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If it works, another green balloon will appear to let you know:&lt;/li&gt;
&lt;/ol&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://pros.cs.purdue.edu/images/atom/upgrade-success.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;If the balloon is red, that means the conductor failed to upgrade the project successfully. In this case, follow any instructions in the balloon and try again.&lt;/p&gt;

&lt;h3 id=&#34;what-now&#34;&gt;What now?&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;re done&amp;ndash; now go make something cool!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>