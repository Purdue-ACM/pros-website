<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Getting-starteds on PROS</title>
    <link>https://pros.cs.purdue.edu/getting-started/index.xml</link>
    <description>Recent content in Getting-starteds on PROS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MPL 2.0 license</copyright>
    <atom:link href="https://pros.cs.purdue.edu/getting-started/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Programming the Clawbot</title>
      <link>https://pros.cs.purdue.edu/getting-started/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pros.cs.purdue.edu/getting-started/</guid>
      <description>

&lt;h4 id=&#34;objective&#34;&gt;Objective:&lt;/h4&gt;

&lt;p&gt;This tutorial will guide you through basic programming of the VEX Clawbot.&lt;/p&gt;

&lt;h4 id=&#34;intended-audience&#34;&gt;Intended Audience:&lt;/h4&gt;

&lt;p&gt;This tutorial is intended for developers with some programming experience, but with little to no experience with the PROS library. If you haven&amp;rsquo;t programmed before, we recommend checking out all the &amp;ldquo;Introduction and Basic C Features&amp;rdquo; sections of &lt;a href=&#34;http://www.cprogramming.com/tutorial/c-tutorial.html&#34;&gt;this tutorial series&lt;/a&gt;; you may also benefit from the &amp;ldquo;Pointers, Arrays and Strings&amp;rdquo; sections as well (although they aren&amp;rsquo;t as pertintent).&lt;/p&gt;

&lt;h4 id=&#34;goals&#34;&gt;Goals:&lt;/h4&gt;

&lt;p&gt;At the end of this tutorial you will have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Understood the basic project structure of PROS&lt;/li&gt;
&lt;li&gt;Programmed a basic chassis with &amp;ldquo;tank&amp;rdquo; control or &amp;ldquo;arcade&amp;rdquo; control&lt;/li&gt;
&lt;li&gt;Programmed buttons to control the clawbot&amp;rsquo;s lift&lt;/li&gt;
&lt;li&gt;Programmed a joystick axis to control the clawbot&amp;rsquo;s claw&lt;/li&gt;
&lt;li&gt;Understood the standard subsystem module methodology&lt;/li&gt;
&lt;li&gt;Programmed a dead-reckoned autonomous routine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here&amp;rsquo;s the robot we&amp;rsquo;ll be programming:

&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/tuts/clawbot1.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;For the purposes of this tutorial, we&amp;rsquo;ve plugged in our motors into the following ports:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Port&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Port&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Left wheels&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Right wheels&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Lift&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Claw&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We modified our clawbot to include a quadrature encoder on the lift arm. We plugged the top and bottom ports into digital ports 2 and 3, respectively.&lt;/p&gt;

&lt;p&gt;With Atom started, you can create a new PROS project by clicking the &lt;code&gt;PROS&lt;/code&gt; menu, then click &lt;code&gt;Create new Project&lt;/code&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/atom/menu-create-new.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Create a directory that you&amp;rsquo;d like to keep the source files for your Clawbot project. We&amp;rsquo;re creating ours in &lt;code&gt;C:\Users\Elliot\dev\Clawbot&lt;/code&gt;.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/atom/window-create-new.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;Pick a directory to create the new project in and click Create. The PROS CLI will now copy the latest kernel template into the specified directory and Atom will open it.

&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/atom/proj-brand-new.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;pros-project-structure&#34;&gt;PROS Project Structure&lt;/h2&gt;

&lt;p&gt;When you create your project, PROS will copy all of the files necessary to build your project. The structure of the project looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;project
│   project.pros        (used by PROS CLI to know kernel version and other metadata)
│   Makefile            (instructs make how to compile your project)
|   common.mk           (helper file for Makefile)
│
└───src                 (source files should go here)
│   │   auto.c          (source for autonomous function)
│   │   init.c          (source for initialization)
│   │   opcontrol.c     (source for operator control)
│   │   Makefile        (instructs make how to compile your source files)
|
└───include             (Header files should go in here)
│   │   API.h           (Lets source files know PROS API functions)
│   │   main.h          (Includes API.h and anything else you want to include project-wide)
│   
└───firmware
    │   cortex.ld       (Instructs the linker how to construct binaries for the Cortex)
    │   libpros.a       (Pre-compiled PROS library)
    |   STM32F10x.ld    (Instructs the linker how to construct binaries for the Cortex)
    |   uniflash.jar    (Legacy flashing utility built w/Java)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Convention Awareness&lt;/p&gt;
&lt;p&gt;By convention, the &lt;code&gt;opcontrol()&lt;/code&gt;, &lt;code&gt;autonomous()&lt;/code&gt;, and initialize functions are separated into separate files (opcontrol.c, auto.c, and init.c). They could be all in the same file, but it can be helpful to organize your functions into multiple files to keep things from becoming messy.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;arcade-control&#34;&gt;Arcade Control&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s begin by writing a basic &amp;ldquo;arcade&amp;rdquo; control for the clawbot. In arcade control, the vertical joystick values control the forward/backward speed of the robot and the horizontal joystick values control the rotation of the robot. Atom will open&lt;code&gt;src/opcontrol.c&lt;/code&gt; for you when you create a project, but if it is not open then you will need to open it by navigating the directory tree on the left panel.&lt;/p&gt;

&lt;p&gt;The template &lt;code&gt;opcontrol.c&lt;/code&gt; file contains a simple infinite loop and documentation to help remind you what &lt;code&gt;opcontrol()&lt;/code&gt; does.&lt;/p&gt;

&lt;p&gt;PROS offers functions to perform common tasks associated with programming robotics. To program basic arcade functionality, we need to be aware of two functions: one to get the joystick input and one to set the motors to a speed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int joystickGetAnalog ( unsigned char joystick,   // the joystick slot to check (1 for master, 2 for partner)
                        unsigned char axis        // One of the joystick channels on a VEX Joystick: 1, 2, 3, 4, ACCEL_X, or ACCEL_Y
                      );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gets the value of a control axis on the VEX joystick.
&lt;em&gt;&lt;strong&gt;Returns&lt;/strong&gt; the value from -127 to 127, or 0 if no joystick is connected to the requested slot.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void motorSet ( unsigned char channel,  // motor channel to set from 1-10
                int speed               // new signed speed. -127 is full reverse, 127 full forward, 0 off
              );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sets the speed of the specified motor channel.&lt;/p&gt;

&lt;p&gt;Armed with knowledge of these functions, let&amp;rsquo;s modify &lt;code&gt;opcontrol()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void operatorControl() {
  int power;
  int turn;
    while (1) {
        power = joystickGetAnalog(1, 2); // vertical axis on left joystick
        turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
        motorSet(2, power + turn); // set left wheels
        motorSet(3, power - turn); // set right wheels
        delay(20);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Commenting Code&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s considered good practice to comment your code. Commenting can make it easier to understand the original intention of code when you have to look back on it months later in the middle of the competition and everything&amp;rsquo;s broken.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your code should tell the story of what you are doing; your comments should tell the story of why you are doing it.
&lt;em&gt;(Source: &lt;a href=&#34;http://stackoverflow.com/a/142869&#34;&gt;http://stackoverflow.com/a/142869&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;compilation&#34;&gt;Compilation&lt;/h2&gt;

&lt;p&gt;Next, you will need to &lt;strong&gt;compile&lt;/strong&gt; your project. Compilation converts your code into instructions the Cortex can understand. There are typically four stages to compilation. The following paragraphs explain abstract complicated technical systems. This introduction to compilation is intended to give some justification for the compilation process, but is by no means complete. &lt;strong&gt;This information is not necessary to program with PROS, but may be helpful for some.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1. Preprocessing&lt;/p&gt;

&lt;p&gt;Lines starting with a &lt;code&gt;#&lt;/code&gt; are interpreted by the preprocessor as commands. These commands can include other pieces of files (&lt;code&gt;#include&lt;/code&gt;), execute basic macro logic (&lt;code&gt;#ifdef&lt;/code&gt;), replace text (&lt;code&gt;#define&lt;/code&gt;), and more. The goal of preprocessing is to reduce duplicated code.&lt;/p&gt;

&lt;p&gt;For instance, to call the PROS API, all of the &lt;em&gt;function declarations&lt;/em&gt; need to go in the source file. Using a &lt;em&gt;header file&lt;/em&gt; can simplify this operation by writing all of the function declarations in one place, and just &lt;code&gt;#include&lt;/code&gt;-ing it to reference those function declarations.&lt;/p&gt;

&lt;p&gt;2. Compilation&lt;/p&gt;

&lt;p&gt;The next stage of compilation is to translate preprocessed code into &lt;em&gt;assembly instructions&lt;/em&gt; that the ARM Cortex-M3 processor can almost understand. Assembly code is human readable and reasonably converted into a language that the processor can understand.&lt;/p&gt;

&lt;p&gt;3. Assembly&lt;/p&gt;

&lt;p&gt;The assembler translates assembly instructions directly into machine code (called &lt;em&gt;object code&lt;/em&gt; or &lt;em&gt;objects&lt;/em&gt;). These files aren&amp;rsquo;t considered human readable and can be interpreted by the processor directly.&lt;/p&gt;

&lt;p&gt;4. Linking&lt;/p&gt;

&lt;p&gt;The final stage of compilation is linking. Objects contain pieces of machine instructions, but may not be complete. For instance, when compiling your source files, the PROS API are not directly incorporated into your object code (merely references to the PROS API functions, as specified by the function declarations). The Linker will incorporate and rearrange all the different object files (and libraries) into one file that &lt;em&gt;can&lt;/em&gt; be interpreted by the processor.&lt;/p&gt;

&lt;p&gt;To compile code within Atom, press &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt; to bring up the Command Palette. You can start typing the command you wish to execute, &amp;ldquo;Build: Trigger&amp;rdquo;. You should also notice that it will display the available shortcut keys to execute the command. By default, triggering a build can be done by pressing &lt;code&gt;Ctrl&lt;/code&gt;+&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt; (&lt;code&gt;⌘&lt;/code&gt;+&lt;code&gt;Alt&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt;) or &lt;code&gt;F9&lt;/code&gt;. If you have unsaved files, Build will prompt you to save those files. You should always save before building.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/atom/build.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;uploading&#34;&gt;Uploading Code to the Cortex&lt;/h2&gt;

&lt;p&gt;Now that you have compiled a binary file that the Cortex can understand, you need to upload it to the microcontroller. Within Atom, click the &amp;lsquo;Upload to Cortex&amp;rsquo; button in Atom. This process will upload the binary the compilation process created (&lt;code&gt;bin/output.bin&lt;/code&gt;) to the Cortex and begin running it.&lt;/p&gt;

&lt;p&gt;If you followed these instructions correctly, you can connect a joystick to the clawbot and drive it using arcade controls!&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/atom/upload.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h2 id=&#34;subsystem-methodology&#34;&gt;Subsystem Module Methodology&lt;/h2&gt;

&lt;p&gt;In this section, we&amp;rsquo;ll introduce the subsystem module methodology. When developing code for complicated robotic systems, it&amp;rsquo;s extremely helpful to abstract away the necessary steps to perform actions on a system. For instance, to set the speed of a 4 motor chassis, you may need to set the speed of the front left motor, the rear left motor, and so on. You might just have four &lt;code&gt;motorSet()&lt;/code&gt; calls every time you want to set robot&amp;rsquo;s speed, but what happens when you add another pair of motors to your chassis, or collapse your left and right sides onto two Y-cables? You would need to comb through all of your code to find all of the times you set the chassis speeds and adjust those calls accordingly. Similarly, you may want a level of abstraction for getting sensor values - what happens if you decide to switch from quadrature encoders to integrated motor encoders?&lt;/p&gt;

&lt;p&gt;Writing a function such as &lt;code&gt;chassisSet()&lt;/code&gt; can help mitigate this problem. Additionally, you cannot write your &lt;code&gt;chassisSet()&lt;/code&gt; function in multiple source files, so you need to create a single source file and be able to incorporate it with &lt;code&gt;opcontrol.c&lt;/code&gt;, &lt;code&gt;init.c&lt;/code&gt;, and &lt;code&gt;auto.c&lt;/code&gt;. The subsystem module methodology is a standard way of organizing these sorts of functions. We define a subsystem as a major component of a robot: chassis, lift, intake, and claw are some common subsystems. We&amp;rsquo;ll write our abstracted subsystem functions in a file like &lt;code&gt;src/chassis.c&lt;/code&gt; and put our function declarations in &lt;code&gt;include/chassis.h&lt;/code&gt; so that way we can call our new functions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s modify our existing operator control to use the subsystem methodology. We&amp;rsquo;ll begin by creating the header file containing our function declarations. You can create a new file in the &lt;code&gt;include&lt;/code&gt; directory by right clicking &lt;code&gt;include&lt;/code&gt; and clicking &amp;ldquo;New File&amp;rdquo;. We&amp;rsquo;ll name our file &lt;code&gt;chassis.h&lt;/code&gt;. A new empty file is created for us. Header files contain declarations, but not typically definitions. They are a way to describe what resources are available to you.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your own header files contain declarations for interfaces between the source files of your program. Each time you have a group of related declarations and macro definitions all or most of which are needed in several different source files, it is a good idea to create a header file for them. &lt;em&gt;(&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html&#34;&gt;GNU&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;include/chassis.h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef _CHASSIS_H_
#define _CHASSIS_H_

// Sets the speeds of the left and right wheels of the chassis
void chassisSet(int left, int right);

#endif // _CHASSIS_H_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/chassis.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;    // includes API.h and other headers
#include &amp;quot;chassis.h&amp;quot; // redundant, but ensures that the corresponding header file (chassis.h) is included

void chassisSet(int left, int right) {
  motorSet(2, left);
  motorSet(3, right);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this methodology, we can rewrite our operator control to something much more concise:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;
#include &amp;quot;chassis.h&amp;quot;

void opcontrol() {
  while(1) {
    int power, turn;
    while (1) {
      power = joystickGetAnalog(1, 2); // vertical axis on left joystick
      turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
      chassisSet(power + turn, power - turn);
      delay(20);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should be clear that congregating similar pieces of code into a C source file and a header file for other source files simplifies and organizes your code.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Reduce even more&lt;/p&gt;
&lt;p&gt;You can modify &lt;code&gt;main.h&lt;/code&gt; and include your own header files. In our example, we could modify our &lt;code&gt;main.h&lt;/code&gt; to look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// top of main.h omitted
#ifndef MAIN_H_

// This prevents multiple inclusion, which isn&#39;t bad for this file but is good practice
#define MAIN_H_

#include &amp;lt;API.h&amp;gt;
#include &amp;quot;chassis.h&amp;quot; // Added this line

// rest of main.h omitted from this listing
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in &lt;code&gt;opcontrol.c&lt;/code&gt;, the only file we would need to &lt;code&gt;#include&lt;/code&gt; is &lt;code&gt;main.h&lt;/code&gt;. In future source files, we would only ever need to &lt;code&gt;#include &amp;quot;main.h&amp;quot;&lt;/code&gt; in order to get access to all of our robot&amp;rsquo;s subsystems&amp;rsquo; functions!&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;claw&#34;&gt;Programming the VEX Claw&lt;/h2&gt;

&lt;p&gt;We now want to use the left horizontal joystick to control the aperture of the claw. We&amp;rsquo;ll continue using the modular methodology:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;include/claw.h&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifndef _CLAW_H_
#define _CLAW_H_

void clawSet(int speed);

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/claw.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;
#include &amp;quot;claw.h&amp;quot;

void clawSet(int speed) {
  motorSet(9, -speed);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/opcontrol.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void operatorControl() {
  int power, turn;
  while (1) {
    power = joystickGetAnalog(1, 2); // vertical axis on left joystick
    turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
    chassisSet(power + turn, power - turn);

    // add the following line:
    clawSet(joystickGetAnalog(1, 4));

    delay(20);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your project structure should now look something like this:

&lt;figure &gt;
    
        &lt;img src=&#34;https://pros.cs.purdue.edu/images/tuts/clawbot-atom.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;lift&#34;&gt;Controlling the Lift&lt;/h2&gt;

&lt;p&gt;Our drivers requested that they be able to use the trigger buttons to control the lift. At this point, complete the lift submodule on your own just like we did for the chassis and claw. If you&amp;rsquo;re having trouble, take a look at the complete Clawbot code sample at the bottom of this page.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/opcontrol.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void operatorControl() {
  int power, turn;
    while (1) {
    power = joystickGetAnalog(1, 2); // vertical axis on left joystick
    turn  = joystickGetAnalog(1, 1); // horizontal axis on left joystick
    chassisSet(power + turn, power - turn);

    clawSet(joystickGetAnalog(1, 4));

    // add the following logic:
    if(joystickGetDigital(1, 6, JOY_UP)) {
      liftSet(127); // pressing up, so lift should go up
    }
    else if(joystickGetDigital(1, 6, JOY_DOWN)) {
      liftSet(-127); // pressing down, so lift should go down
    }
    else {
      liftSet(0); // no buttons are pressed, stop the lift
    }

    delay(20);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on your motor, you may notice that the arm falls back down when stopped mid-raise. This can be alleviated by applying some power to the motor when no buttons are pressed (instead of 0), or by using a control system such as PID.&lt;/p&gt;

&lt;h2 id=&#34;autonomous&#34;&gt;Writing a simple autonomous&lt;/h2&gt;

&lt;p&gt;Now that we&amp;rsquo;ve written our code using subsystem modules, writing an autonomous can be simple. In autonomous mode, your robot receives no input from the joystick and operates on its own logic. This mode is typically initiated by a competition controller (&lt;a href=&#34;http://www.vexrobotics.com/vexedr/products/competition-products/276-2335.html&#34;&gt;field&lt;/a&gt; or &lt;a href=&#34;http://www.vexrobotics.com/vexedr/products/competition-products/275-1401.html&#34;&gt;switch&lt;/a&gt;), however you can call &lt;code&gt;autonomous()&lt;/code&gt; like you would any other function.&lt;/p&gt;

&lt;p&gt;Our autonomous routine will be simple: we want to drive forward for 3.5 seconds and lift the claw for 2 seconds, then rotate left/right every 3 seconds 3 times. Hopefully, this autonomous will score our preload object and knock an object into a scored position.&lt;/p&gt;

&lt;p&gt;The code to accomplish this looks like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/auto.c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;main.h&amp;quot;

void autonomous() {
  chassisSet(127, 127); // drive forward
  delay(3500); // delay 3.5 seconds = 3500 milliseconds
  chassisSet(0, 0); // stop driving forward
  liftSet(127); // lift goes up
  delay(2000);
  liftSet(0);
  for(int i = 0; i &amp;lt; 3; i++) {
    chassisSet(-127, 127); // rotate left
    delay(1000);
    chassisSet(127, -127); // rotate right for twice as long \\--/
    delay(2000);
  }
  chassisSet(0, 0); // stop chassis for safety, although potentially not necessary
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may notice that this code runs quite inconsistently. Time delayed autonomous routines do not provide the robot with any progress reports. Due to variations caused by wheels slipping, motor output speed due to battery voltage, and other factors, a time delayed autonomous will rarely perform better than an autonomous using sensor feedback. To create a better autonomous routine, the Internet provides lots of a resources for creating commonly used feedback controllers like the PID Controller.&lt;/p&gt;

&lt;p&gt;Congratulations you have completed your first PROS program!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pros.cs.purdue.edu/clawbot.zip&#34;&gt;Complete source code is available here.&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing on Windows</title>
      <link>https://pros.cs.purdue.edu/getting-started/windows/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pros.cs.purdue.edu/getting-started/windows/</guid>
      <description>

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;PROS for Atom is the new best way to program for VEX Robotics. Getting started with PROS is easy on Windows.&lt;/p&gt;

&lt;p&gt;To begin, &lt;a href=&#34;https://github.com/purduesigbots/pros/releases/latest&#34;&gt;download&lt;/a&gt; and run the installer. Please note
that an Internet connection is required throughout the installation process.&lt;/p&gt;

&lt;p&gt;Most users will wish to complete the typical installation process, which will install the PROS Core components
(the PROS CLI and GCC toolchain) and Atom with Clang and the PROS plugin. If you already have Atom installed, then
the installer will simply add the PROS plugin to your existing Atom environment.&lt;/p&gt;

&lt;p&gt;If VEX drivers haven&amp;rsquo;t previously been installed, you will be prompted to install the official drivers released
by VEX.&lt;/p&gt;

&lt;p&gt;Once the installation is completed, Atom can be started via the Start Menu or Desktop shortcut.&lt;/p&gt;

&lt;h2 id=&#34;issues-and-notes-about-installation&#34;&gt;Issues and Notes about Installation&lt;/h2&gt;

&lt;h3 id=&#34;apm-failure&#34;&gt;APM Failure&lt;/h3&gt;

&lt;p&gt;During some installations, Atom may not install correctly. This is best diagnosed by there not being shortcuts to
Atom after installation, or if &lt;code&gt;apm&lt;/code&gt; isn&amp;rsquo;t on PATH. If this is the case, you may need to manually install Atom by visiting
&lt;a href=&#34;https://atom.io/download/windows&#34;&gt;https://atom.io/download/windows&lt;/a&gt;. Once installed and Atom appears, you will be able to install the PROS plugin by pressing
&lt;strong&gt;Win&lt;/strong&gt;+&lt;strong&gt;R&lt;/strong&gt; and entering &lt;code&gt;apm install file-icons linter tool-bar tool-bar-main busy build platformio-ide-terminal pros&lt;/code&gt;. If you are still having trouble after installing Atom manually, it may be necessary to add Atom to &lt;code&gt;PATH&lt;/code&gt; manually as well. To do so, follow these instructions:
1. Find the location of atom.exe. One good way of doing this is by right clicking on the Atom shortcut on your dekstop, clicking &amp;lsquo;Open File Location,&amp;rsquo; and copying the path from the Explorer address bar.
2. Windows 7/8/8.1:
  1. Open the Start menu
  2. Right click on &amp;lsquo;Computer&amp;rsquo;
  3. Select &amp;lsquo;Properties&amp;rsquo;
  4. Click &amp;lsquo;Advanced System Settings&amp;rsquo;
  5. Click &amp;lsquo;Environment Variables&amp;rsquo;
  6. Select &amp;lsquo;PATH&amp;rsquo; under &amp;lsquo;User Variables,&amp;rsquo; then click &amp;lsquo;Edit&amp;rsquo;
  7. Add a semicolon (&lt;code&gt;;&lt;/code&gt;) to the end of the value, then paste in the path to atom.exe
  8. Click &amp;lsquo;OK&amp;rsquo;
3. Windows 10:
  1. Type &amp;lsquo;Environment Variables&amp;rsquo; into the search bar
  2. Select &amp;lsquo;Edit environment variables for your account
  3. Select &amp;lsquo;Path&amp;rsquo; in the upper box
  4. Click &amp;lsquo;Edit,&amp;rsquo; then click &amp;lsquo;New&amp;rsquo;
  5. Paste in the path to atom.exe
  6. Click &amp;lsquo;OK&amp;rsquo;&lt;/p&gt;

&lt;h3 id=&#34;installing-alongside-pros-for-eclipse&#34;&gt;Installing alongside PROS for Eclipse&lt;/h3&gt;

&lt;p&gt;It is possible to install Atom alongside Eclipse, if you have previously installed Eclipse. However, the uninstall utility for
PROS for Eclipse will remove all the contents in &lt;code&gt;C:\Program Files\PROS&lt;/code&gt;, so the new version of PROS will also be affected.
If you decide to remove Eclipse but want to keep the PROS Core components, either run the PROS for Eclipse uninstall utility and
reinstall/repair the new version of PROS or manually delete all files/folders in &lt;code&gt;C:\Program Files\PROS&lt;/code&gt; except: &lt;code&gt;C:\Program Files\PROS\cli-64&lt;/code&gt;
(or just &lt;code&gt;cli&lt;/code&gt; if x86), &lt;code&gt;C:\Program Files\PROS\toolchain&lt;/code&gt;, &lt;code&gt;C:\Program Files\PROS\updater.exe&lt;/code&gt;, and &lt;code&gt;C:\Program Files\PROS\updater.ini&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing on macOS</title>
      <link>https://pros.cs.purdue.edu/getting-started/os-x/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pros.cs.purdue.edu/getting-started/os-x/</guid>
      <description>

&lt;h2 id=&#34;installation-instructions&#34;&gt;Installation Instructions&lt;/h2&gt;

&lt;p&gt;Installing PROS on macOS could not be easier with our custom built installer! Just follow these instructions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Install &lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;Python 3&lt;/a&gt;(Version 3.4 or higher) for macOS.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Download the &lt;a href=&#34;https://github.com/purduesigbots/pros/releases/tag/2.11.0&#34;&gt;PROS installer&lt;/a&gt; and run it. You will need to input an administrator&amp;rsquo;s password, and must remain connected to the internet for the duration of installation. The installer will download Atom.app and the ARM toolchain to &lt;code&gt;/Applications/PROS_2.0&lt;/code&gt;, and will use pip3 to install the command line interface. You will be able to see the progress of the installer in a Terminal window automatically openned by the installer.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Open Atom (&lt;code&gt;/Applications/PROS_2.0/Atom.app&lt;/code&gt;) and verify that PROS appears in the menu (Likely next to Help).&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Congratulations! You have successfully installed PROS for macOS. If you want autocomlete functionality within Atom for your PROS code, download either &lt;a href=&#34;https://itunes.apple.com/us/app/xcode/id497799835?mt=12#&#34;&gt;Xcode&lt;/a&gt; or &lt;a href=&#34;http://llvm.org&#34;&gt;LLVM&lt;/a&gt;. Xcode is easier to install than LLVM, but you must open the application at least once and its command line tools must be installed.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Minimum OS version:     10.8&lt;/li&gt;
&lt;li&gt;Minimum Python Version:     3.4&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;known-issues&#34;&gt;Known issues&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Downloading code to the cortex must be done through the programming kit. You cannot download code through a direct tether.&lt;/li&gt;
&lt;li&gt;Atom may be unable to update itself when saved in &lt;code&gt;/Applications&lt;/code&gt;. If this is the case, move it to &lt;code&gt;~/Desktop&lt;/code&gt;, &lt;code&gt;~/Applications&lt;/code&gt;, or any other folder owned by your current user.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Installing on Linux</title>
      <link>https://pros.cs.purdue.edu/getting-started/debian-linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pros.cs.purdue.edu/getting-started/debian-linux/</guid>
      <description>

&lt;h2 id=&#34;easy-install-scripts&#34;&gt;Easy Install Scripts&lt;/h2&gt;

&lt;p&gt;If you are installing on Ubuntu or Arch linux there are install scripts available which should handle most of the process. The scripts can be downloaded from Github:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu:&lt;/strong&gt; &lt;a href=&#34;https://github.com/purduesigbots/pros/releases/download/2.11.0/pros-install_ubuntu.sh&#34;&gt;pros-install_ubuntu.sh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Arch Linux:&lt;/strong&gt; &lt;a href=&#34;https://github.com/purduesigbots/pros/releases/download/2.11.0/pros-install_arch.sh&#34;&gt;pros-install_arch.sh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; When using PROS for linux you cannot program or interact with a cortex directly tethered via A-A. This is a &lt;a href=&#34;https://pros.cs.purdue.edu/known-issues/#linuxAA&#34;&gt;known issue&lt;/a&gt; with a simple solution.&lt;/p&gt;

&lt;h2 id=&#34;other-distro-installation-requirements&#34;&gt;Other Distro Installation Requirements&lt;/h2&gt;

&lt;p&gt;To follows these instructions you need an operating system on your machine which is not Windows. We recommend the latest version of Ubuntu LTS. If you choose to not use Ubuntu LTS be sure that the flavor of linux you are using has support for the following packages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://atom.io/&#34;&gt;Atom 1.10.x+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;git 2.x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://llvm.org/releases/download.html&#34;&gt;clang 3.9.0+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://launchpad.net/gcc-arm-embedded/+download&#34;&gt;gcc-arm-none-eabi 4.7.1+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;python3 3.5+&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;python3-pip&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you have downloaded and install all those packages type the following command to install the PROS atom plugins:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apm install file-icons linter tool-bar tool-bar-main busy build pros
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upon completion open Atom and it will finish the setup process. Now you are all set to use PROS!!!&lt;/p&gt;

&lt;p&gt;If you have any issues with these instructions be sure to report the issues on our &lt;a href=&#34;https://github.com/purduesigbots/pros-atom&#34;&gt;github project&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>